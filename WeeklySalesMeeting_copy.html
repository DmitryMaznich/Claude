<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sales Weekly Sync</title>
    <link rel="icon" type="image/svg+xml" href="logo.svg">
    <link rel="shortcut icon" type="image/svg+xml" href="logo.svg">
    <link rel="apple-touch-icon" href="logo.svg">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Salesforce Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: white;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background: white;
            border: 1px solid #dddbda;
            border-radius: 4px;
            padding: 20px;
            max-width: 900px;
            width: 100%;
            position: relative;
        }

        .header {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #dddbda;
            position: relative;
        }

        .title {
            font-size: 16px;
            font-weight: 600;
            color: #080707;
            text-align: center;
        }

        .week-info {
            position: absolute;
            right: 0;
            font-size: 13px;
            color: #0176d3;
            cursor: pointer;
        }

        .speedometer-section {
            background: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 4px;
            border: 1px solid #dddbda;
            position: relative;
        }

        .frame-number {
            position: absolute;
            top: 5px;
            left: 5px;
            background-color: #0176d3;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            z-index: 100;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .fullscreen-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: rgba(1, 118, 211, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            z-index: 10001;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            pointer-events: none;
        }

        .fullscreen-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: #0176d3;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            z-index: 100;
            transition: background-color 0.3s;
            line-height: 1;
        }

        .fullscreen-btn:hover {
            background-color: #014486;
        }

        .fullscreen-btn:active {
            background-color: #001639;
        }

        .section-fullscreen {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            max-width: 100vw !important;
            margin: 0 !important;
            z-index: 9999 !important;
            border-radius: 0 !important;
            overflow: auto !important;
            background: white !important;
            padding: 40px !important;
            display: flex !important;
            flex-direction: column !important;
            justify-content: flex-start !important;
            align-items: center !important;
            box-sizing: border-box !important;
        }

        /* Fullscreen –¥–ª—è —Ç–∞–±–ª–∏—Ü */
        .section-fullscreen .change-group {
            width: 90% !important;
            max-width: 1600px !important;
            margin: 0 auto !important;
            overflow: visible !important;
            max-height: none !important;
            display: flex !important;
            flex-direction: column !important;
        }

        .section-fullscreen .change-group-header {
            width: 100% !important;
            padding: 20px 80px 20px 24px !important;
            box-sizing: border-box !important;
            flex-shrink: 0 !important;
        }

        .section-fullscreen .table-container {
            width: 100% !important;
            overflow: auto !important;
            max-height: calc(100vh - 200px) !important;
            flex: 1 1 auto !important;
        }

        .section-fullscreen table {
            width: 100% !important;
            font-size: 1em !important;
            table-layout: auto !important;
            display: table !important;
        }

        .section-fullscreen table thead,
        .section-fullscreen table tbody,
        .section-fullscreen table tr {
            display: table-row-group !important;
        }

        .section-fullscreen table tr {
            display: table-row !important;
        }

        /* Allow hidden rows to stay hidden even in fullscreen */
        .section-fullscreen table tr[style*="display: none"] {
            display: none !important;
        }

        .section-fullscreen table th,
        .section-fullscreen table td {
            display: table-cell !important;
        }

        .section-fullscreen .change-title {
            font-size: 1.3em !important;
        }

        .section-fullscreen .change-summary {
            font-size: 1.2em !important;
        }

        .section-fullscreen .change-icon {
            font-size: 1.3em !important;
        }

        .section-fullscreen .chart-header {
            margin-bottom: 5px !important;
            padding-bottom: 5px !important;
            width: 90% !important;
            max-width: 1600px !important;
        }

        .section-fullscreen .chart-title {
            font-size: 1.8em !important;
        }

        .section-fullscreen .chart-subtitle {
            font-size: 1.2em !important;
        }

        /* Fullscreen –¥–ª—è canvas –¥–∏–∞–≥—Ä–∞–º–º - –æ–≥—Ä–∞–Ω–∏—á–∏–º —Ä–∞–∑–º–µ—Ä –¥–æ 70% */
        .section-fullscreen canvas {
            max-width: 70% !important;
            max-height: 70vh !important;
            width: auto !important;
            height: auto !important;
            margin: 0 auto !important;
        }

        /* –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –¥–ª—è —Å–ø–∏–¥–æ–º–µ—Ç—Ä–∞ - –æ–Ω –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –±–æ–ª—å—à–∏–º –≤ fullscreen */
        .section-fullscreen #speedometer {
            max-width: 900px !important;
            width: 900px !important;
            height: 450px !important;
            max-height: none !important;
        }

        .section-fullscreen .speedometer-container {
            max-width: 900px !important;
        }

        /* –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –¥–ª—è –≤—Ç–æ—Ä–æ–π –¥–∏–∞–≥—Ä–∞–º–º—ã (Domain Bar Chart) - —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–æ */
        .section-fullscreen #domainBarChart {
            max-width: 1200px !important;
            width: 1200px !important;
            height: 600px !important;
            max-height: none !important;
        }

        .speedometer-container {
            position: relative;
            width: 100%;
            max-width: 700px;
            margin: 0 auto;
            padding: 10px 0 20px 0;
            min-height: 320px;
        }

        .speedometer-container canvas {
            display: block;
            max-width: 100%;
            height: auto;
            margin: 0 auto;
        }

        /* –ü–æ–∑–¥—Ä–∞–≤–∏—Ç–µ–ª—å–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è: –ü—É–ª—å—Å–∞—Ü–∏—è —Å –∑–µ–ª–µ–Ω—ã–º —Å–∏—è–Ω–∏–µ–º */
        @keyframes celebration-pulse {
            0%, 100% {
                transform: scale(1);
                filter: drop-shadow(0 0 5px rgba(6, 165, 154, 0.3));
            }
            50% {
                transform: scale(1.03);
                filter: drop-shadow(0 0 25px rgba(6, 165, 154, 0.9));
            }
        }

        .speedometer-celebration {
            animation: celebration-pulse 2s ease-in-out infinite;
        }

        #domainBarChart {
            display: block;
            max-width: 100%;
            height: auto;
        }

        .cumulative-chart-container {
            position: relative;
            width: 100%;
            max-width: 900px;
            height: 500px;
            margin: 0 auto;
            overflow: visible;
        }

        #cumulativeChart {
            display: block;
            width: 100% !important;
            height: 100% !important;
            max-width: none !important;
        }

        .center-value {
            text-align: center;
            margin-top: 10px;
        }

        .main-value {
            font-size: 52px;
            font-weight: 700;
            color: #06a59a;
            line-height: 1;
        }

        .percentage {
            font-size: 38px;
            font-weight: 700;
            color: #706e6b;
            margin-left: 8px;
        }

        /* Fix center-value position in fullscreen mode */
        .section-fullscreen .center-value {
            margin-top: 80px;
            position: relative;
        }

        .section-fullscreen .main-value {
            font-size: 52px;
        }

        .section-fullscreen .percentage {
            font-size: 38px;
        }

        .footer-info {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
            padding-top: 15px;
            border-top: 1px solid #dddbda;
            font-size: 13px;
            color: #706e6b;
        }

        .footer-left {
            color: #0176d3;
            cursor: pointer;
        }

        .footer-right {
            color: #706e6b;
        }

        .file-upload {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            border: 1px solid #dddbda;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 1000;
            max-width: 300px;
        }

        .upload-toggle {
            width: 100%;
            padding: 12px 16px;
            background: #0176d3;
            color: white;
            border: none;
            border-radius: 4px 4px 0 0;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.2s;
        }

        .upload-toggle:hover {
            background: #014486;
        }

        #uploadToggleIcon {
            transition: transform 0.3s;
            font-size: 10px;
        }

        .file-upload.collapsed #uploadToggleIcon {
            transform: rotate(-90deg);
        }

        .upload-content {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 500px;
            overflow-y: auto;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }

        .file-upload.collapsed .upload-content {
            max-height: 0;
            padding: 0 10px;
            overflow: hidden;
        }

        .upload-section {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .file-upload input[type="file"] {
            display: none;
        }

        .file-upload label {
            padding: 8px 16px;
            border-radius: 3px;
            background: #f3f2f2;
            color: #706e6b;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            display: inline-block;
            border: 1px solid #dddbda;
            text-align: center;
        }

        .file-upload label:hover {
            background: #e5e5e5;
            border-color: #c9c7c5;
        }

        .download-btn {
            padding: 8px 16px;
            border-radius: 3px;
            background: #0176d3;
            color: white;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            border: none;
            transition: all 0.2s;
        }

        .download-btn:hover:not(:disabled) {
            background: #014486;
        }

        .download-btn:disabled {
            background: #c9c7c5;
            cursor: not-allowed;
        }

        .file-hint {
            font-size: 10px;
            color: #706e6b;
            font-style: italic;
        }

        .file-status {
            margin-top: 8px;
            font-size: 11px;
            color: #706e6b;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 3px;
        }

        .date-selector-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .date-selector-group label {
            font-size: 12px;
            color: #706e6b;
            font-weight: 500;
            white-space: nowrap;
        }

        .date-selector-group input[type="date"],
        .date-selector-group select {
            padding: 6px 10px;
            border-radius: 3px;
            border: 1px solid #dddbda;
            background: #f3f2f2;
            color: #080707;
            font-size: 12px;
            cursor: pointer;
        }

        .date-selector-group input[type="date"]:hover,
        .date-selector-group select:hover {
            background: #e5e5e5;
            border-color: #c9c7c5;
        }

        .date-selector-group select {
            min-width: 110px;
        }

        .bar-chart-section {
            position: relative;
            margin-top: 40px;
            padding: 20px;
            background: white;
            border: 1px solid #dddbda;
            border-radius: 4px;
        }

        .chart-header {
            margin-bottom: 5px;
            padding-bottom: 5px;
            border-bottom: 1px solid #dddbda;
        }

        .chart-title {
            font-size: 16px;
            font-weight: 600;
            color: #080707;
            margin-bottom: 4px;
        }

        .chart-subtitle {
            font-size: 12px;
            color: #706e6b;
        }

        /* –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å—Ç–∏–ª–∏ –¥–ª—è –∑–∞–≥–æ–ª–æ–≤–∫–∞ —Å–ø–∏–¥–æ–º–µ—Ç—Ä–∞ */
        #speedometerTitle {
            font-size: 28px !important;
            font-weight: 700 !important;
            text-align: center !important;
            color: #0176d3 !important;
            margin-bottom: 8px !important;
        }

        #speedometerSubtitle {
            font-size: 13px !important;
            text-align: left !important;
        }

        .chart-legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            margin-bottom: 10px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 4px;
            position: relative;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            display: inline-block;
        }

        .legend-line {
            width: 20px;
            height: 20px;
            display: inline-block;
            position: relative;
        }

        .legend-line::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 3px;
            background: repeating-linear-gradient(
                to right,
                #0176d3 0,
                #0176d3 5px,
                transparent 5px,
                transparent 8px
            );
        }

        .legend-line::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 50%;
            transform: translateX(-50%);
            width: 6px;
            height: 6px;
            background: #0176d3;
            border-radius: 50%;
        }

        .legend-text {
            font-size: 13px;
            color: #333;
            font-weight: 500;
        }

        .funnel-container {
            margin-top: 20px;
        }

        .funnel-summary {
            text-align: center;
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .funnel-total {
            font-size: 16px;
            font-weight: 600;
            color: #333;
        }

        .funnel-total span {
            color: #0176d3;
            font-size: 18px;
        }

        #pipelineFunnel {
            display: block;
            max-width: 100%;
            height: auto;
        }

        .table-section {
            margin-top: 40px;
            padding: 20px;
            background: white;
            border: 1px solid #dddbda;
            border-radius: 4px;
            position: relative;
        }

        .table-container {
            overflow-x: auto;
        }

        .slds-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .slds-table thead {
            background: #f3f2f2;
        }

        .slds-table th {
            padding: 12px 8px;
            text-align: left;
            font-weight: 600;
            color: #080707;
            border-bottom: 2px solid #dddbda;
        }

        .slds-table td {
            padding: 12px 8px;
            border-bottom: 1px solid #dddbda;
            color: #080707;
        }

        .slds-table tbody tr:hover {
            background: #f3f2f2;
        }

        .slds-table .amount-cell {
            font-weight: 600;
            color: #0176d3;
        }

        .change-group {
            margin-bottom: 30px;
            position: relative;
            display: block;
        }

        .change-group-header {
            padding: 12px 50px 12px 16px;
            border-radius: 4px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            box-sizing: border-box;
        }

        .table-container {
            display: block;
        }

        .table-container table {
            width: 100%;
        }

        .closed-header {
            background: #d9f0d1;
            color: #2e7d32;
        }

        .progressed-header {
            background: #d4edda;
            color: #155724;
        }

        .slipped-header {
            background: #fff3cd;
            color: #856404;
        }

        .new-header {
            background: #d1ecf1;
            color: #0c5460;
        }

        .lost-header {
            background: #f8d7da;
            color: #721c24;
        }

        .change-icon {
            font-size: 16px;
        }

        .change-title {
            font-size: 13px;
            letter-spacing: 0.5px;
        }

        .change-summary {
            margin-left: auto;
            font-size: 13px;
            font-weight: 400;
        }

        .compact-table {
            font-size: 12px;
        }

        .compact-table th,
        .compact-table td {
            padding: 8px;
        }

        .cumulative-stats {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .stat-box {
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #0176d3;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 12px;
            color: #706e6b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* ===== MOBILE & RESPONSIVE STYLES ===== */
        @media (max-width: 768px) {
            body {
                padding: 5px;
                align-items: flex-start;
            }
            
            .container {
                padding: 10px;
                width: 100%;
                max-width: 100%;
            }
            
            .title {
                font-size: 20px !important;
                margin-bottom: 5px;
            }
            
            .week-info {
                font-size: 11px !important;
            }
            
            .controls {
                flex-direction: column !important;
                gap: 10px !important;
            }
            
            .slds-button {
                width: 100% !important;
                padding: 12px !important;
                font-size: 14px;
            }
            
            .chart-header .chart-title {
                font-size: 16px !important;
            }
            
            .chart-header .chart-subtitle {
                font-size: 10px !important;
            }
            
            .speedometer-section,
            .bar-chart-section,
            .table-section {
                padding: 15px !important;
                margin-bottom: 15px !important;
            }
            
            .value-display {
                font-size: 32px !important;
            }
            
            .percentage-display {
                font-size: 18px !important;
            }
            
            .today-target-label {
                font-size: 11px !important;
            }
            
            .footer-info {
                flex-direction: column !important;
                gap: 8px !important;
                text-align: left !important;
            }
            
            .footer-left,
            .footer-right {
                font-size: 11px !important;
            }
            
            .chart-legend {
                flex-direction: column !important;
                gap: 10px !important;
                padding: 10px !important;
            }
            
            .legend-item {
                justify-content: center;
            }
            
            .legend-text {
                font-size: 11px !important;
            }
            
            .cumulative-chart-container {
                height: 300px !important;
                max-width: 100% !important;
            }
            
            .cumulative-stats {
                flex-direction: column !important;
                gap: 15px !important;
                padding: 15px !important;
            }
            
            .stat-box {
                width: 100%;
            }
            
            .stat-value {
                font-size: 20px !important;
            }
            
            .stat-label {
                font-size: 11px !important;
            }
            
            /* Make tables scrollable on mobile */
            .table-container {
                overflow-x: auto !important;
                -webkit-overflow-scrolling: touch;
            }
            
            .slds-table {
                min-width: 600px;
                font-size: 11px !important;
            }
            
            .slds-table th,
            .slds-table td {
                padding: 6px 4px !important;
            }
            
            .compact-table {
                font-size: 11px !important;
            }
            
            .change-group {
                margin-bottom: 20px !important;
            }
            
            .change-group-header {
                flex-wrap: wrap;
                padding: 10px 12px !important;
                gap: 5px !important;
            }
            
            .change-icon {
                font-size: 16px !important;
            }
            
            .change-title {
                font-size: 11px !important;
            }
            
            .change-summary {
                font-size: 10px !important;
                width: 100%;
                text-align: left;
                margin-left: 0 !important;
                margin-top: 3px;
            }
            
            .file-upload {
                bottom: 10px !important;
                right: 10px !important;
                left: 10px !important;
                max-width: none !important;
            }

            .upload-toggle {
                font-size: 12px !important;
                padding: 10px 12px !important;
            }
            
            .file-upload label {
                padding: 10px 16px !important;
                font-size: 12px !important;
            }

            .download-btn {
                padding: 10px 16px !important;
                font-size: 12px !important;
            }
            
            .file-status {
                font-size: 10px !important;
            }
            
            .fullscreen-btn {
                padding: 10px 15px !important;
                font-size: 12px !important;
            }
            
            .section-fullscreen {
                padding: 10px !important;
            }
            
            .section-fullscreen .fullscreen-btn {
                position: fixed !important;
                top: 10px !important;
                right: 10px !important;
                z-index: 10000 !important;
            }
        }

        /* Tablet adjustments */
        @media (min-width: 769px) and (max-width: 1024px) {
            body {
                padding: 15px;
            }
            
            .container {
                padding: 15px;
            }
            
            .controls {
                gap: 10px !important;
            }
            
            .slds-button {
                padding: 10px 15px !important;
                font-size: 13px !important;
            }
            
            .stat-value {
                font-size: 20px;
            }
        }

        .controls {
            display: flex;
            gap: 8px;
            margin-top: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .slds-button {
            padding: 10px 20px;
            border-radius: 4px;
            border: 1px solid #c9c7c5;
            background: white;
            color: #0176d3;
            font-size: 13px;
            font-weight: 400;
            cursor: pointer;
            transition: all 0.2s;
        }

        .slds-button:hover {
            background: #f3f2f2;
            border-color: #0176d3;
        }

        .slds-button.active {
            background: #0176d3;
            color: white;
            border-color: #0176d3;
        }

        /* Q1 Outlook Styles */
        .q1-outlook-content {
            margin: 20px 0;
            padding: 20px;
            background: white;
        }

        .q1-header-row {
            display: grid;
            grid-template-columns: 65% 35%;
            padding: 10px 0;
            border-bottom: 2px solid #dddbda;
            margin-bottom: 15px;
            font-size: 11px;
            font-weight: 600;
            color: #706e6b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .q1-header-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .q1-header-right {
            border-left: 2px solid #dddbda;
            padding-left: 20px;
        }

        .q1-domain-row {
            display: grid;
            grid-template-columns: 65% 35%;
            padding: 15px 0;
            border-bottom: 1px solid #f3f2f2;
        }

        .q1-domain-row:last-child {
            border-bottom: none;
        }

        .q1-left-section {
            display: flex;
            align-items: center;
            gap: 15px;
            padding-right: 20px;
        }

        .q1-domain-name {
            font-size: 12px;
            font-weight: 600;
            color: #080707;
            min-width: 110px;
            text-align: right;
        }

        .q1-qualified-bar-wrapper {
            flex: 1;
            position: relative;
        }

        .q1-qualified-bar {
            display: flex;
            height: 36px;
            border-radius: 3px;
            overflow: hidden;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            position: relative;
        }

        .q1-stage-segment {
            height: 100%;
            transition: opacity 0.2s;
            cursor: pointer;
        }

        .q1-stage-segment:hover {
            opacity: 0.85;
        }

        .q1-bar-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: 700;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            white-space: nowrap;
            pointer-events: none;
            z-index: 10;
        }

        .q1-right-section {
            border-left: 2px solid #dddbda;
            padding-left: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .q1-early-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .q1-early-bar-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .q1-early-bar {
            display: flex;
            height: 18px;
            border-radius: 2px;
            overflow: hidden;
            box-shadow: 0 1px 1px rgba(0,0,0,0.08);
        }

        .q1-early-segment {
            height: 100%;
            transition: opacity 0.2s;
            cursor: pointer;
        }

        .q1-early-segment:hover {
            opacity: 0.85;
        }

        .q1-early-identification {
            background: #757575;
        }

        .q1-early-qualification {
            background: #BDBDBD;
        }

        .q1-early-label {
            font-size: 11px;
            color: #616161;
            white-space: nowrap;
        }

        .q1-sellers-wrapper {
            display: flex;
            gap: 3px;
            align-items: center;
            padding-top: 4px;
        }

        .q1-sellers-row {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .q1-sellers-label {
            font-size: 12px;
            color: #706e6b;
            min-width: 90px;
        }

        .q1-seller-icons {
            display: flex;
            gap: 3px;
            margin-right: 15px;
        }

        .q1-seller-icon {
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .q1-seller-icon:hover {
            transform: scale(1.3);
        }

        .q1-seller-count {
            font-size: 12px;
            color: #706e6b;
        }

        .q1-summary-metrics {
            margin: 25px 0;
            padding: 20px;
            background: #f3f2f2;
            border-radius: 4px;
            border: 1px solid #dddbda;
        }

        .q1-summary-grid {
            display: flex;
            justify-content: space-around;
            gap: 40px;
            flex-wrap: wrap;
        }

        .q1-summary-item {
            text-align: center;
        }

        .q1-summary-label {
            display: block;
            font-size: 11px;
            color: #706e6b;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .q1-summary-value {
            display: block;
            font-size: 18px;
            font-weight: 700;
            color: #080707;
        }

        .q1-summary-item.highlight .q1-summary-value {
            color: #0176d3;
            font-size: 20px;
        }

        .q1-summary-item.success .q1-summary-value {
            color: #2e844a;
        }

        .q1-summary-item.warning .q1-summary-value {
            color: #fe9339;
        }

        .q1-summary-item.danger .q1-summary-value {
            color: #c23934;
        }

        .q1-legend {
            margin: 20px 0 15px 0;
            display: flex;
            justify-content: center;
            gap: 30px;
            align-items: center;
            flex-wrap: wrap;
            font-size: 10px;
        }

        .q1-legend .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .q1-legend .legend-text {
            font-size: 10px;
            color: #706e6b;
        }

        .q1-legend .legend-prob {
            font-size: 10px;
            color: #a8a8a8;
        }

        .legend-color-box {
            width: 14px;
            height: 14px;
            border-radius: 2px;
            display: inline-block;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .legend-symbol {
            font-size: 16px;
            display: inline-block;
            width: 20px;
            text-align: center;
        }

        .legend-prob {
            font-size: 10px;
            color: #706e6b;
            font-style: italic;
        }

        .legend-divider {
            height: 1px;
            background: #dddbda;
            margin: 15px 0;
        }

        .q1-axis-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            padding: 0 10px;
            font-size: 10px;
            color: #706e6b;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="title" id="domainTitle">Accelerator</div>
            <div class="week-info" id="weekInfo">Closed in week [24.11 - 30.11] = 15k</div>
        </div>
        
        <div class="speedometer-section" id="speedometerSection" data-frame="1">
            <div class="frame-number">1</div>
            <button class="fullscreen-btn" onclick="toggleFullscreen('speedometerSection')">‚õ∂</button>
            <div class="chart-header">
                <div class="chart-title" id="speedometerTitle">Accelerator Booking progress on Dec 7, 2025</div>
            </div>

            <div class="speedometer-container">
                <canvas id="speedometer" width="700" height="320"></canvas>
            </div>

            <div class="center-value">
                <span class="main-value" id="valueDisplay">‚Ç¨2,5M</span>
                <span class="percentage" id="percentDisplay">(83%)</span>
            </div>

            <div class="footer-info">
                <div class="footer-left" id="targetInfo">Target for Week [24.11 - 30.11] = ‚Ç¨3.0M</div>
                <div class="footer-right" id="dateInfo">As of 24. nov. 2025, 10:27</div>
            </div>

            <div class="controls" id="controlsDiv">
                <button class="slds-button" onclick="switchDomain('overall')">All Domains</button>
                <button class="slds-button active" onclick="switchDomain('accelerator')">Accelerator</button>
                <button class="slds-button" onclick="switchDomain('fusion')">Fusion</button>
                <button class="slds-button" onclick="switchDomain('radiationoncology')">Radiation Oncology</button>
                <button class="slds-button" onclick="switchDomain('semiconductor')">Semiconductor</button>
                <button class="slds-button" onclick="switchDomain('quantum')">Quantum</button>
                <button class="slds-button" onclick="switchDomain('other')">Other</button>
            </div>
        </div>

        <!-- Horizontal Bar Chart Section -->
        <div class="bar-chart-section" id="barChartSection" data-frame="2">
            <div class="frame-number">2</div>
            <button class="fullscreen-btn" onclick="toggleFullscreen('barChartSection')">‚õ∂</button>
            <div class="chart-header">
                <div class="chart-title">Booking by Domain</div>
                <div class="chart-subtitle">Fiscal Year Progress</div>
                <div class="chart-period-booking" id="barChartPeriodBooking" style="font-size: 13px; color: #706e6b; margin-top: 5px;"></div>
            </div>

            <canvas id="domainBarChart" width="700" height="450"></canvas>

            <div class="chart-legend">
                <div class="legend-item">
                    <span class="legend-color" style="background-color: #0176d3;"></span>
                    <span class="legend-text">Booking (Before Period)</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color" style="background-color: #2E844A;"></span>
                    <span class="legend-text">Booking (During Period)</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color" style="background-color: #c9c7c5;"></span>
                    <span class="legend-text">Qualified Pipeline (Open for FY25)</span>
                </div>
                <div class="legend-item">
                    <span class="legend-line"></span>
                    <span class="legend-text">FY25 Target</span>
                </div>
            </div>
        </div>

        <!-- Closing This Week Section -->
        <div class="table-section" id="closingThisWeekSection" data-frame="5">
            <div class="frame-number">5</div>
            <button class="fullscreen-btn" onclick="toggleFullscreen('closingThisWeekSection')">‚õ∂</button>

            <div class="change-group" id="closingThisWeekGroup">
                <div class="change-group-header" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                    <span class="change-icon">üìÖ</span>
                    <span class="change-title" id="closingThisWeekTitle">CLOSING THIS WEEK</span>
                    <span class="change-summary" id="closingThisWeekSummary">(0 deals, ‚Ç¨0)</span>
                </div>
                <div class="table-container">
                    <table class="slds-table compact-table">
                        <thead>
                            <tr>
                                <th style="width: 40px;">#</th>
                                <th>Opportunity Name</th>
                                <th>Domain</th>
                                <th>Owner</th>
                                <th>Amount</th>
                                <th>Close Date</th>
                                <th>Stage</th>
                            </tr>
                        </thead>
                        <tbody id="closingThisWeekBody">
                            <tr><td colspan="7" style="text-align: center; color: #706e6b;">No deals closing this week</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Closing This Month Section -->
        <div class="table-section" id="closingThisMonthSection" data-frame="6">
            <div class="frame-number">6</div>
            <button class="fullscreen-btn" onclick="toggleFullscreen('closingThisMonthSection')">‚õ∂</button>

            <div class="change-group" id="closingThisMonthGroup">
                <div class="change-group-header" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);">
                    <span class="change-icon">üìÜ</span>
                    <span class="change-title" id="closingThisMonthHeader">CLOSING THIS MONTH</span>
                    <span class="change-summary" id="closingThisMonthSummary">(0 deals, ‚Ç¨0)</span>
                </div>
                <div class="table-container">
                    <table class="slds-table compact-table">
                        <thead>
                            <tr>
                                <th style="width: 40px;">#</th>
                                <th>Opportunity Name</th>
                                <th>Domain</th>
                                <th>Owner</th>
                                <th>Amount</th>
                                <th>Close Date</th>
                                <th>Stage</th>
                            </tr>
                        </thead>
                        <tbody id="closingThisMonthBody">
                            <tr><td colspan="7" style="text-align: center; color: #706e6b;">No deals closing this month</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Pipeline Funnel Chart Section -->
        <!-- Pipeline Funnel Chart Section -->
        <div class="bar-chart-section" id="pipelineFunnelSection" data-frame="3">
            <div class="frame-number">3</div>
            <button class="fullscreen-btn" onclick="toggleFullscreen('pipelineFunnelSection')">‚õ∂</button>
            <div class="chart-header">
                <div class="chart-title">Qualified Pipeline by Stage (FY25)</div>
                <div class="chart-subtitle">Current FY Open Opportunities</div>
            </div>
            <div class="funnel-summary">
                <div class="funnel-total">Total: <span id="funnelTotal">‚Ç¨0</span></div>
            </div>
            <canvas id="pipelineFunnel" width="700" height="500"></canvas>
        </div>

        <!-- Closed Deals Section -->
        <div class="table-section" id="closedSection" data-frame="7">
            <!-- Closed Deals Group -->
            <div class="change-group" id="closedGroup">
                <div class="frame-number">7</div>
                <button class="fullscreen-btn" onclick="toggleFullscreen('closedGroup')">‚õ∂</button>
                <div class="change-group-header closed-header">
                    <span class="change-icon">‚úÖ</span>
                    <span class="change-title" id="closedTitle">CLOSED THIS PERIOD</span>
                    <span class="change-summary" id="closedSummary">(0 deals, ‚Ç¨0)</span>
                </div>
                <div class="table-container">
                    <table class="slds-table compact-table">
                        <thead>
                            <tr>
                                <th style="width: 40px;">#</th>
                                <th>Opportunity Name</th>
                                <th>Domain</th>
                                <th>Owner</th>
                                <th>Amount</th>
                                <th>Close Date</th>
                            </tr>
                        </thead>
                        <tbody id="closedProgressBody">
                            <tr><td colspan="6" style="text-align: center; color: #706e6b;">No changes</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Progressed Deals Section -->
        <div class="table-section" id="progressedSection" data-frame="8">
            <!-- Progressed Deals Group -->
            <div class="change-group" id="progressedGroup">
                <div class="frame-number">8</div>
                <button class="fullscreen-btn" onclick="toggleFullscreen('progressedGroup')">‚õ∂</button>
                <div class="change-group-header progressed-header">
                    <span class="change-icon">üü¢</span>
                    <span class="change-title" id="progressedTitle">PROGRESSED</span>
                    <span class="change-summary-center" id="progressedSummaryCenter" style="flex: 1; text-align: center;"></span>
                    <span class="change-summary" id="progressedSummary">(0 deals)</span>
                </div>
                <div class="table-container">
                    <table class="slds-table compact-table">
                        <thead>
                            <tr>
                                <th style="width: 40px;">#</th>
                                <th>Opportunity Name</th>
                                <th>Domain</th>
                                <th>Owner</th>
                                <th>Amount</th>
                                <th>Close Date</th>
                                <th>Stage Change</th>
                            </tr>
                        </thead>
                        <tbody id="progressedBody">
                            <tr><td colspan="7" style="text-align: center; color: #706e6b;">No changes</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Slipped Deals Section -->
        <div class="table-section" id="slippedSection" data-frame="9">
            <!-- Slipped Deals Group -->
            <div class="change-group" id="slippedGroup">
                <div class="frame-number">9</div>
                <button class="fullscreen-btn" onclick="toggleFullscreen('slippedGroup')">‚õ∂</button>
                <div class="change-group-header slipped-header">
                    <span class="change-icon">‚ö†Ô∏è</span>
                    <span class="change-title" id="slippedTitle">SLIPPED</span>
                    <span class="change-summary-center" id="slippedSummaryCenter" style="flex: 1; text-align: center;"></span>
                    <span class="change-summary" id="slippedSummary">(0 deals)</span>
                </div>
                <div class="table-container">
                    <table class="slds-table compact-table">
                        <thead>
                            <tr>
                                <th style="width: 40px;">#</th>
                                <th>Opportunity Name</th>
                                <th>Domain</th>
                                <th>Owner</th>
                                <th>Amount</th>
                                <th>Date Change</th>
                            </tr>
                        </thead>
                        <tbody id="slippedBody">
                            <tr><td colspan="6" style="text-align: center; color: #706e6b;">No changes</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- New Opportunities Section -->
        <div class="table-section" id="newDealsSection" data-frame="10">
            <!-- New Deals Group -->
            <div class="change-group" id="newDealsGroup">
                <div class="frame-number">10</div>
                <button class="fullscreen-btn" onclick="toggleFullscreen('newDealsGroup')">‚õ∂</button>
                <div class="change-group-header new-header">
                    <span class="change-icon">üÜï</span>
                    <span class="change-title" id="newDealsTitle">NEW OPPORTUNITIES</span>
                    <span class="change-summary" id="newSummary">(0 deals)</span>
                </div>
                <div class="table-container">
                    <table class="slds-table compact-table">
                        <thead>
                            <tr>
                                <th style="width: 40px;">#</th>
                                <th>Opportunity Name</th>
                                <th>Domain</th>
                                <th>Owner</th>
                                <th>Amount</th>
                                <th>Close Date</th>
                                <th>Stage</th>
                            </tr>
                        </thead>
                        <tbody id="newDealsBody">
                            <tr><td colspan="7" style="text-align: center; color: #706e6b;">No changes</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Lost & Disengaged Section -->
        <div class="table-section" id="lostSection" data-frame="11">
            <!-- Lost & Disengaged Group -->
            <div class="change-group" id="lostGroup">
                <div class="frame-number">11</div>
                <button class="fullscreen-btn" onclick="toggleFullscreen('lostGroup')">‚õ∂</button>
                <div class="change-group-header lost-header">
                    <span class="change-icon">‚ùå</span>
                    <span class="change-title" id="lostTitle">LOST & DISENGAGED</span>
                    <span class="change-summary" id="lostSummary">(0 deals, ‚Ç¨0)</span>
                </div>
                <div class="table-container">
                    <table class="slds-table compact-table">
                        <thead>
                            <tr>
                                <th style="width: 40px;">#</th>
                                <th>Opportunity Name</th>
                                <th>Domain</th>
                                <th>Owner</th>
                                <th>Amount</th>
                                <th>Final Stage</th>
                                <th>Reason</th>
                            </tr>
                        </thead>
                        <tbody id="lostBody">
                            <tr><td colspan="7" style="text-align: center; color: #706e6b;">No changes</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Close Date Changes Section -->
        <div class="table-section" id="closeDateChangesSection" data-frame="12">
            <div class="frame-number">12</div>
            <div class="change-group" id="closeDateChangesGroup">
                <button class="fullscreen-btn" onclick="toggleFullscreen('closeDateChangesGroup')">‚õ∂</button>
                <div class="change-group-header" style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);">
                    <span class="change-icon">üìÖ</span>
                    <span class="change-title">CLOSE DATE CHANGES HISTORY</span>
                    <span class="change-summary" id="closeDateChangesSummary">(0 opportunities)</span>
                    <div style="margin-left: auto; display: flex; gap: 8px; position: relative; z-index: 100;">
                        <button onclick="expandAllOwnerGroups()" style="padding: 4px 12px; font-size: 11px; background: white; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; position: relative; z-index: 101;">Expand All</button>
                        <button onclick="collapseAllOwnerGroups()" style="padding: 4px 12px; font-size: 11px; background: white; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; position: relative; z-index: 101;">Collapse All</button>
                    </div>
                </div>
                <div class="table-container">
                    <table class="slds-table compact-table">
                        <thead>
                            <tr>
                                <th style="width: 40px;">#</th>
                                <th>Opportunity Name</th>
                                <th>Owner</th>
                                <th>Initial Close Date</th>
                                <th style="text-align: right;">Initial Amount</th>
                                <th style="text-align: center;">Changes Count</th>
                                <th style="text-align: center; width: 80px;">Slippage (days)</th>
                                <th>Final Close Date</th>
                                <th style="text-align: right;">Final Amount</th>
                                <th style="text-align: center; width: 90px;">Œî %</th>
                            </tr>
                        </thead>
                        <tbody id="closeDateChangesBody">
                            <tr><td colspan="10" style="text-align: center; color: #706e6b;">No data available</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Open Opportunities Close Date Changes Section -->
        <div class="table-section" id="openCloseDateChangesSection" data-frame="13">
            <div class="frame-number">13</div>
            <div class="change-group" id="openCloseDateChangesGroup">
                <button class="fullscreen-btn" onclick="toggleFullscreen('openCloseDateChangesGroup')">‚õ∂</button>
                <div class="change-group-header" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);">
                    <span class="change-icon">üìä</span>
                    <span class="change-title">OPEN OPPORTUNITIES - CLOSE DATE CHANGES</span>
                    <span class="change-summary" id="openCloseDateChangesSummary">(0 opportunities)</span>
                </div>
                <div class="table-container">
                    <table class="slds-table compact-table">
                        <thead>
                            <tr>
                                <th style="width: 40px;">#</th>
                                <th>Opportunity Name</th>
                                <th>Owner</th>
                                <th>Initial Close Date</th>
                                <th style="text-align: right;">Initial Amount</th>
                                <th style="text-align: center;">Changes Count</th>
                                <th style="text-align: center; width: 80px;">Slippage (days)</th>
                                <th>Current Close Date</th>
                                <th style="text-align: right;">Current Amount</th>
                                <th style="text-align: center; width: 90px;">Œî %</th>
                            </tr>
                        </thead>
                        <tbody id="openCloseDateChangesBody">
                            <tr><td colspan="10" style="text-align: center; color: #706e6b;">No data available</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Cumulative Booking Chart Section -->
        <div class="bar-chart-section" id="cumulativeChartSection" data-frame="4">
            <div class="frame-number">4</div>
            <button class="fullscreen-btn" onclick="toggleFullscreen('cumulativeChartSection')">‚õ∂</button>
            <div class="chart-header">
                <div class="chart-title">Cumulative Booking Progress</div>
                <div class="chart-subtitle">Actual Closed Won + Projected Pipeline by Month</div>
            </div>
            <div class="cumulative-chart-container">
                <canvas id="cumulativeChart" width="900" height="450"></canvas>
            </div>
            <div class="chart-legend">
                <div class="legend-item">
                    <span class="legend-color" style="background-color: #4472C4;"></span>
                    <span class="legend-text">Actual Closed Won</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color" style="background-color: #E74C3C;"></span>
                    <span class="legend-text">Projected Pipeline</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color" style="background-color: #FF8C00; border: 2px dashed #FF8C00;"></span>
                    <span class="legend-text">Previous Period Plan</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color" style="background-color: #000000;"></span>
                    <span class="legend-text">Target</span>
                </div>
            </div>
        </div>

        <!-- Q1 FY26 Pipeline Outlook -->
        <div class="speedometer-section" id="q1OutlookSection" data-frame="14">
            <div class="frame-number">14</div>
            <button class="fullscreen-btn" onclick="toggleFullscreen('q1OutlookSection')">‚õ∂</button>
            <div class="speedometer-header">
                <div class="speedometer-title" style="font-size: 32px; font-weight: 700;">Q1 FY26 Pipeline Outlook</div>
                <div class="speedometer-subtitle">Peek Around the Corner ‚Ä¢ Apr - Jun 2026</div>
            </div>
            <div id="q1OutlookContent" class="q1-outlook-content">
                <!-- Content will be dynamically generated -->
            </div>
            <div class="q1-legend">
                <div class="legend-item">
                    <span class="legend-color-box" style="background: #FE9339;"></span>
                    <span class="legend-text">Value Creation <span class="legend-prob">(65%)</span></span>
                </div>
                <div class="legend-item">
                    <span class="legend-color-box" style="background: #0176D3;"></span>
                    <span class="legend-text">A Winning Proposal <span class="legend-prob">(90%)</span></span>
                </div>
                <div class="legend-item">
                    <span class="legend-color-box" style="background: #9050E9;"></span>
                    <span class="legend-text">Obtaining Final Commitment <span class="legend-prob">(99%)</span></span>
                </div>
                <div class="legend-item">
                    <span class="legend-color-box" style="background: #2E844A;"></span>
                    <span class="legend-text">Finalisation <span class="legend-prob">(100%)</span></span>
                </div>
            </div>
            <div class="q1-summary-metrics" id="q1SummaryMetrics">
                <!-- Summary metrics will be inserted here -->
            </div>
        </div>

        <div class="file-upload collapsed" id="fileUploadSection">
            <button class="upload-toggle" onclick="toggleUploadSection()">
                <span id="uploadToggleIcon">‚ñº</span> Settings & Data Upload
            </button>
            
            <div class="upload-content" id="uploadContent">
                <div class="upload-section">
                    <input type="file" id="currentPipelineFile" accept=".csv" onchange="loadCurrentPipeline(event)">
                    <label for="currentPipelineFile">üìä Load Current Pipeline</label>
                    <span class="file-hint">Upload Pipeline_General_Overview.csv</span>
                </div>

                <div class="upload-section">
                    <input type="file" id="fieldHistoryFile" accept=".csv" onchange="loadFieldHistory(event)">
                    <label for="fieldHistoryFile">üìú Load Field History</label>
                    <span class="file-hint">Upload Opportunity_History.csv</span>
                </div>


                <div class="upload-section">
                    <label for="fullscreenSequenceInput" style="font-weight: 600; color: #080707;">Fullscreen sequence (frame numbers)</label>
                    <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap; margin-top: 6px;">
                        <input type="text" id="fullscreenSequenceInput" placeholder="1,2,5" style="flex: 1 1 220px; min-width: 160px; padding: 6px 10px; border-radius: 3px; border: 1px solid #dddbda; background: #f3f2f2; color: #080707; font-size: 12px;">
                        <button type="button" class="slds-button" style="padding: 8px 12px;" onclick="startFullscreenSequence()">Start sequence</button>
                        <button type="button" class="slds-button" style="padding: 8px 12px; background: #f3f2f2; color: #080707;" onclick="stopFullscreenSequence()">Stop</button>
                    </div>
                    <div class="file-hint">Enter frame numbers separated by commas (e.g., 1,2,7). Sequence will loop in fullscreen.</div>
                </div>

                <div class="upload-section" style="border-top: 1px solid #e5e5e5; padding-top: 15px; margin-top: 15px;">
                    <div style="margin-bottom: 10px; font-weight: 600; color: #080707;">‚öôÔ∏è Calculation Settings</div>
                    <div class="date-selector" style="display: flex; gap: 20px; flex-wrap: wrap;">
                        <div class="date-selector-group">
                            <label for="targetDate">As of:</label>
                            <input type="date" id="targetDate" onchange="updateTargetDate(event)">
                        </div>
                        <div class="date-selector-group">
                            <label for="periodRange">Period:</label>
                            <select id="periodRange" onchange="updatePeriodRange(event)">
                                <option value="7" selected>1 Week</option>
                                <option value="14">2 Weeks</option>
                                <option value="21">3 Weeks</option>
                                <option value="30">1 Month</option>
                                <option value="60">2 Months</option>
                                <option value="90">3 Months</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="file-status" id="fileStatus"></div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('speedometer');
        const ctx = canvas.getContext('2d');

        // High-DPI canvas setup to prevent pixelation
        function setupHighDPICanvas(canvas) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();

            // Set display size (css pixels)
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';

            // Set actual size in memory (scaled to account for extra pixel density)
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;

            // Scale the drawing context to match
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);

            return ctx;
        }

        // Apply high-DPI setup initially
        setupHighDPICanvas(canvas);

        // ============================================
        // CONFIGURATION - STAGE PROBABILITIES
        // ============================================
        // Centralized configuration for stage win rates
        // Edit these values to adjust probability weights for pipeline calculations
        const STAGE_PROBABILITIES = {
            // Early stages (using average deal size for estimation)
            'Opportunity Identification': 0.30,        // 30% - very early stage
            'Opportunity Qualification': 0.50,         // 50% - passed initial qualification
            // Qualified stages
            'Value Creation': 0.65,                    // 65% - after qualification
            'A Winning Proposal': 0.90,                // 90% - after winning proposal
            'Obtaining Final Commitment': 0.99,        // 99% - commitment received
            'Finalisation': 1.00                       // 100% - contract signed, waiting for PO
        };

        // Average deal size for early stage estimation
        const AVERAGE_DEAL_SIZE = 170000; // ‚Ç¨170k - average deal size

        // Q1 FY26 Configuration
        const Q1_FY26_CONFIG = {
            start: new Date('2026-04-01'),
            end: new Date('2026-06-30'),
            target: 4977500, // ‚Ç¨4.98M target for Q1 (FY25 annual ‚Ç¨18.1M / 4 √ó 1.10 growth)
            earlyStages: ['Opportunity Identification', 'Opportunity Qualification'],
            qualifiedStages: ['Value Creation', 'A Winning Proposal', 'Obtaining Final Commitment', 'Finalisation'],
            stageColors: {
                'Value Creation': '#FE9339',              // Salesforce Orange
                'A Winning Proposal': '#0176D3',          // Salesforce Blue
                'Obtaining Final Commitment': '#9050E9',  // Salesforce Purple
                'Finalisation': '#2E844A'                 // Salesforce Green
            }
        };

        // Fiscal Year configuration
        const FY_START = new Date('2025-04-01');
        const FY_END = new Date('2026-03-31');
        
        // Current "today" date for calculations (can be changed by user)
        let calculationDate = new Date();

        // Period selection for comparison (in days)
        let selectedPeriodDays = 7; // Default: 1 week
        let periodStartDate = null; // Calculated: calculationDate - selectedPeriodDays
        let periodEndDate = null;   // Same as calculationDate

        // Animation state for green bar pulsation
        let greenBarPulseOpacity = 1.0;
        let greenBarPulseDirection = -1; // -1 = fading, +1 = brightening

        // Raw opportunity data from CSV
        let opportunityData = [];
        let snapshotData = []; // Array of all snapshots from file
        let currentPipelineData = null; // Current pipeline state
        let fieldHistoryData = []; // Field history records
        let existingRecords = new Set(); // Track unique records for deduplication
        let availableWeeks = []; // Array of unique SnapshotDate values
        
        // Aggregated domain data (calculated from opportunities)
        let domainData = {};
        
        // Generate unique fingerprint for a record (OpportunityID|Amount|Stage|CloseDate|SnapshotDate)
        function getRecordFingerprint(opp, snapshotDate) {
            return `${opp.OpportunityID}|${opp.Amount}|${opp.Stage}|${opp.CloseDate}|${snapshotDate}`;
        }
        
        // Calculate week range (Monday to Sunday) for given date
        function getWeekRange(date) {
            const d = new Date(date);
            const day = d.getDay(); // 0 = Sunday, 1 = Monday, etc.
            const diff = day === 0 ? -6 : 1 - day; // Adjust to Monday
            
            const monday = new Date(d);
            monday.setDate(d.getDate() + diff);
            
            const sunday = new Date(monday);
            sunday.setDate(monday.getDate() + 6);
            
            const formatDate = (dt) => {
                const day = dt.getDate();
                const month = dt.getMonth() + 1;
                return `${day.toString().padStart(2, '0')}.${month.toString().padStart(2, '0')}`;
            };
            
            return `${formatDate(monday)} - ${formatDate(sunday)}`;
        }
        
        // Calculate days in fiscal year
        function calculateFYProgress() {
            const today = calculationDate;
            const daysPassed = Math.floor((today - FY_START) / (1000 * 60 * 60 * 24));
            const totalDays = Math.floor((FY_END - FY_START) / (1000 * 60 * 60 * 24));
            return { daysPassed, totalDays, ratio: daysPassed / totalDays };
        }

        // Calculate period start and end dates based on selected period
        function calculatePeriodDates() {
            periodEndDate = new Date(calculationDate);
            periodStartDate = new Date(calculationDate);
            periodStartDate.setDate(periodStartDate.getDate() - selectedPeriodDays);

            return { start: periodStartDate, end: periodEndDate };
        }

        // Find closest available snapshot to a target date
        function findClosestSnapshot(targetDate) {
            if (!availableWeeks || availableWeeks.length === 0) return null;

            const targetTime = targetDate.getTime();
            let closest = null;

            // Find the latest snapshot that is <= targetDate (on or before)
            for (let week of availableWeeks) {
                const weekDate = new Date(week);
                if (weekDate.getTime() <= targetTime) {
                    closest = week;
                } else {
                    // Since availableWeeks is sorted, we can stop when we find a date > targetDate
                    break;
                }
            }

            // If no snapshot found before targetDate, use the first one
            if (!closest) {
                closest = availableWeeks[0];
            }

            return closest;
        }

        // Get human-readable period label
        function getPeriodLabel() {
            const periodNames = {
                7: '1 Week',
                14: '2 Weeks',
                21: '3 Weeks',
                30: '1 Month',
                60: '2 Months',
                90: '3 Months'
            };
            return periodNames[selectedPeriodDays] || `${selectedPeriodDays} days`;
        }

        // Format date as DD.MM.YYYY
        function formatDate(date) {
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = date.getFullYear();
            return `${day}.${month}.${year}`;
        }

        // Update period info display with date range
        function updatePeriodInfoDisplay(periods) {
            const periodLabel = getPeriodLabel();
            const startStr = formatDate(periods.start);
            const endStr = formatDate(periods.end);

            // Update week info to show period range
            document.getElementById('weekInfo').textContent =
                `Period: ${startStr} - ${endStr} (${periodLabel})`;
        }

        // Reconstruct opportunity state at a specific date by rolling back changes
        function getOpportunityStateAtDate(opp, targetDate) {
            // Start with current state
            const oppId = opp['Opportunity ID'];
            const state = {
                stage: opp['Stage'],
                closeDate: opp['Close Date'],
                amount: opp['Net Amount'],
                domain: opp['Opportunity Domain'] || 'Other',
                name: opp['Opportunity Name'],
                owner: opp['Opportunity Owner'],
                oppId: oppId
            };

            // Debug check
            if (window.fieldHistoryCheckCount === undefined) {
                window.fieldHistoryCheckCount = 0;
            }
            if (window.fieldHistoryCheckCount === 0) {
                console.log('=== fieldHistoryData check ===');
                console.log('typeof fieldHistoryData:', typeof fieldHistoryData);
                console.log('fieldHistoryData length:', fieldHistoryData ? fieldHistoryData.length : 'undefined');
                console.log('fieldHistoryData:', fieldHistoryData);
                window.fieldHistoryCheckCount++;
            }

            if (!fieldHistoryData || fieldHistoryData.length === 0) {
                console.log('No field history data available');
                return state; // No history available, return current state
            }

            // Find all changes for this opportunity AFTER targetDate
            let changesAfterTarget = fieldHistoryData
                .filter(change => {
                    if (change['Opportunity ID'] !== oppId) return false;
                    const editDateStr = change['Edit Date'];
                    if (!editDateStr) return false;
                    const editDate = parseEuropeanDate(editDateStr);
                    if (!editDate) return false;
                    return editDate > targetDate;
                })
                .sort((a, b) => {
                    // Sort by date ascending (oldest first)
                    const dateA = parseEuropeanDate(a['Edit Date']);
                    const dateB = parseEuropeanDate(b['Edit Date']);
                    return dateA - dateB;
                });

            // Filter out "quick corrections" - changes that were corrected within 5 minutes
            // This protects against admin typos/mistakes
            const QUICK_CORRECTION_THRESHOLD_MS = 5 * 60 * 1000; // 5 minutes
            const filteredChanges = [];

            for (let i = 0; i < changesAfterTarget.length; i++) {
                const change = changesAfterTarget[i];
                const field = change['Field / Event'];
                const newValue = change['New Value'];
                const editDate = parseEuropeanDate(change['Edit Date']);

                // Look for next change to same field
                let correctedQuickly = false;
                for (let j = i + 1; j < changesAfterTarget.length; j++) {
                    const nextChange = changesAfterTarget[j];
                    if (nextChange['Field / Event'] === field) {
                        const nextEditDate = parseEuropeanDate(nextChange['Edit Date']);
                        const timeDiff = nextEditDate - editDate;

                        // If corrected within 5 minutes, skip this change
                        if (timeDiff <= QUICK_CORRECTION_THRESHOLD_MS) {
                            correctedQuickly = true;
                        }
                        break; // Only check the very next change to this field
                    }
                }

                if (!correctedQuickly) {
                    filteredChanges.push(change);
                }
            }

            changesAfterTarget = filteredChanges;

            // Debug logging for first call
            if (window.rollbackDebugCount === undefined) {
                window.rollbackDebugCount = 0;
            }
            if (window.rollbackDebugCount === 0) {
                console.log('First rollback call:');
                console.log('  oppId:', oppId);
                console.log('  targetDate:', targetDate);
                console.log('  changes found after target:', changesAfterTarget.length);
                if (changesAfterTarget.length > 0) {
                    console.log('  first change:', changesAfterTarget[0]);
                }
                window.rollbackDebugCount++;
            }

            // Roll back changes in reverse order (from most recent to oldest)
            for (let i = changesAfterTarget.length - 1; i >= 0; i--) {
                const change = changesAfterTarget[i];
                const field = change['Field / Event'];
                const oldValue = change['Old Value'];

                // Roll back the change
                if (field === 'Stage' && oldValue) {
                    state.stage = oldValue;
                }
                if (field === 'Close Date' && oldValue) {
                    state.closeDate = oldValue;
                }
                if (field === 'Net Amount' && oldValue) {
                    state.amount = oldValue;
                }
            }

            return state;
        }

        // Aggregate opportunity data into domain summaries
        function aggregateDomainData() {
            console.log('>>> aggregateDomainData() CALLED <<<');
            console.log('currentPipelineData length:', currentPipelineData ? currentPipelineData.length : 'NULL');

            const domains = {};

            // Initialize domains with TARGETS
            const domainConfig = {
                'accelerator': { name: 'Accelerator', yearTarget: 4500000 },
                'fusion': { name: 'Fusion', yearTarget: 4725000 },
                'semiconductor': { name: 'Semiconductor', yearTarget: 2000000 },
                'quantum': { name: 'Quantum', yearTarget: 1500000 },
                'radiationoncology': { name: 'Radiation Oncology', yearTarget: 4500000 },
                'other': { name: 'Other', yearTarget: 1500000 }
            };
            
            Object.keys(domainConfig).forEach(key => {
                domains[key] = {
                    name: domainConfig[key].name,
                    actualBooking: 0,
                    bookingBeforeLastWeek: 0,
                    bookingLastWeek: 0,
                    openPipeline: 0,
                    yearTarget: domainConfig[key].yearTarget,
                    weekClosed: '0k',
                    week: 47
                };
            });
            
            // Determine period range based on selected period
            const periods = calculatePeriodDates();

            console.log('=== aggregateDomainData DEBUG ===');
            console.log('calculationDate:', calculationDate);
            console.log('selectedPeriodDays:', selectedPeriodDays);
            console.log('periods:', periods);

            // Qualified stages for pipeline calculation
            const qualifiedStages = ['Value Creation', 'A Winning Proposal', 'Obtaining Final Commitment', 'Finalisation'];

            // Calculate data for each domain
            Object.keys(domains).forEach(domainKey => {
                if (domainKey === 'overall') return;

                // BOOKING: Calculate from currentPipelineData based on CloseDate
                // Booking at END of period = all Closed Won where CloseDate <= periodEndDate
                const endBooking = currentPipelineData
                    .filter(opp => {
                        const domain = opp['Opportunity Domain'] || opp['Domain'] || 'Other';
                        const domKey = domain.toLowerCase().replace(/\s+/g, '');

                        if (domKey !== domainKey) return false;

                        // Reconstruct state at end of period
                        const stateAtEnd = getOpportunityStateAtDate(opp, periods.end);

                        // Check if it was Closed Won at that time
                        if (stateAtEnd.stage !== 'Closed Won') return false;

                        // Check if close date is in FY and before/at period end
                        const closeDate = parseEuropeanDate(stateAtEnd.closeDate);
                        if (!closeDate) return false;
                        const inFY = closeDate >= FY_START && closeDate <= FY_END;

                        return inFY && closeDate <= periods.end;
                    })
                    .reduce((sum, opp) => {
                        const stateAtEnd = getOpportunityStateAtDate(opp, periods.end);
                        const amount = parseEuropeanAmount(stateAtEnd.amount);
                        return sum + amount;
                    }, 0);

                // Booking at START of period = all Closed Won where CloseDate <= periodStartDate
                const startBooking = currentPipelineData
                    .filter(opp => {
                        const domain = opp['Opportunity Domain'] || opp['Domain'] || 'Other';
                        const domKey = domain.toLowerCase().replace(/\s+/g, '');

                        if (domKey !== domainKey) return false;

                        // Reconstruct state at start of period
                        const stateAtStart = getOpportunityStateAtDate(opp, periods.start);

                        // Check if it was Closed Won at that time
                        if (stateAtStart.stage !== 'Closed Won') return false;

                        // Check if close date is in FY and before/at period start
                        const closeDate = parseEuropeanDate(stateAtStart.closeDate);
                        if (!closeDate) return false;
                        const inFY = closeDate >= FY_START && closeDate <= FY_END;

                        return inFY && closeDate <= periods.start;
                    })
                    .reduce((sum, opp) => {
                        const stateAtStart = getOpportunityStateAtDate(opp, periods.start);
                        const amount = parseEuropeanAmount(stateAtStart.amount);
                        return sum + amount;
                    }, 0);

                // PIPELINE: Reconstruct state at calculationDate
                // Debug: log before filtering
                if (domainKey === 'quantum') {
                    console.log('=== QUANTUM PIPELINE START ===');
                    console.log('currentPipelineData length:', currentPipelineData.length);
                    console.log('domainKey:', domainKey);
                }

                const filteredOpps = currentPipelineData
                    .filter(opp => {
                        const domain = opp['Opportunity Domain'] || opp['Domain'] || 'Other';
                        const domKey = domain.toLowerCase().replace(/\s+/g, '');
                        if (domKey !== domainKey) return false;

                        // Reconstruct state at calculationDate
                        const stateAtDate = getOpportunityStateAtDate(opp, periods.end);

                        // Check if in qualified stages at that date
                        if (!qualifiedStages.includes(stateAtDate.stage)) return false;

                        // Check if close date in FY
                        const closeDate = parseEuropeanDate(stateAtDate.closeDate);
                        if (!closeDate) return false;
                        const inFY = closeDate >= FY_START && closeDate <= FY_END;

                        return inFY;
                    });

                // Debug quantum pipeline calculation - ALWAYS log for quantum
                if (domainKey === 'quantum') {
                    console.log('=== QUANTUM PIPELINE DETAIL ===');
                    console.log('Filtered opportunities count:', filteredOpps.length);
                    if (filteredOpps.length > 0) {
                        filteredOpps.slice(0, 5).forEach((opp, idx) => {
                            const stateAtDate = getOpportunityStateAtDate(opp, periods.end);
                            const amount = parseEuropeanAmount(stateAtDate.amount);
                            console.log(`[${idx}] ID=${opp['Opportunity ID']}, Name="${opp['Opportunity Name']}", Amount="${stateAtDate.amount}", Parsed=${amount}`);
                        });
                        if (filteredOpps.length > 5) {
                            console.log(`... and ${filteredOpps.length - 5} more opportunities`);
                        }
                    } else {
                        console.log('NO OPPORTUNITIES IN FILTERED LIST!');
                    }
                }

                const pipeline = filteredOpps.reduce((sum, opp) => {
                    const stateAtDate = getOpportunityStateAtDate(opp, periods.end);
                    const amount = parseEuropeanAmount(stateAtDate.amount);

                    // Debug for quantum only (log first 10 items)
                    if (domainKey === 'quantum' && sum < 2000000) {
                        console.log(`QUANTUM REDUCE: sum=${sum}, adding amount=${amount} (from "${stateAtDate.amount}"), oppId=${opp['Opportunity ID']}, oppName="${opp['Opportunity Name']}", stage="${stateAtDate.stage}", new sum=${sum + amount}`);
                    }

                    return sum + amount;
                }, 0);

                // Set values
                domains[domainKey].actualBooking = endBooking;
                domains[domainKey].openPipeline = pipeline;
                domains[domainKey].bookingBeforeLastWeek = startBooking;
                domains[domainKey].bookingLastWeek = endBooking - startBooking;

                // Debug quantum domain
                if (domainKey === 'quantum') {
                    console.log('=== QUANTUM DEBUG ===');
                    console.log('quantum endBooking:', endBooking);
                    console.log('quantum startBooking:', startBooking);
                    console.log('quantum bookingLastWeek:', endBooking - startBooking);
                    console.log('quantum pipeline:', pipeline);
                    console.log('quantum yearTarget:', domains[domainKey].yearTarget);
                    console.log('quantum actualBooking:', endBooking);
                    console.log('quantum openPipeline:', pipeline);
                    console.log('quantum bookingBeforeLastWeek:', startBooking);
                }
            });
            
            // Add "overall" summary
            const totalTarget = 18100000; // Overall sales target = ‚Ç¨18.1M
            domains['overall'] = {
                name: 'All Domains',
                actualBooking: Object.values(domains).reduce((sum, d) => sum + d.actualBooking, 0),
                bookingBeforeLastWeek: Object.values(domains).reduce((sum, d) => sum + (d.bookingBeforeLastWeek || 0), 0),
                bookingLastWeek: Object.values(domains).reduce((sum, d) => sum + (d.bookingLastWeek || 0), 0),
                openPipeline: Object.values(domains).reduce((sum, d) => sum + d.openPipeline, 0),
                yearTarget: totalTarget,
                weekClosed: '55k',
                week: 47
            };
            
            return domains;
        }

        // Update target date when user changes date picker
        function updateTargetDate(event) {
            try {
                console.log('=== updateTargetDate called ===');
                console.log('event.target.value:', event.target.value);
                calculationDate = new Date(event.target.value);
                console.log('NEW calculationDate:', calculationDate);

                // Recalculate domain data with new date
                domainData = aggregateDomainData();

                // Update period info display
                const periods = calculatePeriodDates();
                updatePeriodInfoDisplay(periods);

                // Switch to Overall domain (simulates clicking "All Domains" button)
                switchDomain('overall');

                // Update period booking and tables
                updatePeriodBookingInfo();
                populateProgressTracking();

                // Update closing tables
                populateClosingTables();
            } catch (error) {
                console.error('‚ùå ERROR in updateTargetDate:', error);
                console.error('Stack trace:', error.stack);
                alert('Error updating date: ' + error.message);
            }
        }

        function updatePeriodRange(event) {
            selectedPeriodDays = parseInt(event.target.value);

            // Recalculate domain data with new period
            domainData = aggregateDomainData();

            // Update period info display
            const periods = calculatePeriodDates();
            updatePeriodInfoDisplay(periods);

            // Switch to Overall domain (simulates clicking "All Domains" button)
            switchDomain('overall');
            
            // Update period booking and tables
            updatePeriodBookingInfo();
            populateProgressTracking();
            
            populateClosingTables();
        }

        // Domain data structure:
        // actualBooking = Current booking (where needle points)
        // openPipeline = Qualified pipeline (Value Creation, A Winning Proposal, Obtaining Final Commitment, Finalisation) with Close Date in FY
        // yearTarget = Target for fiscal year (April 1 - March 31)
        // Initial dummy data - will be replaced when CSV is loaded
        domainData = {
            overall: {
                actualBooking: 0,
                openPipeline: 0,
                yearTarget: 18100000,
                name: 'All Domains',
                weekClosed: '0k',
                week: 47
            },
            accelerator: {
                actualBooking: 0,
                openPipeline: 0,
                yearTarget: 4500000,
                name: 'Accelerator',
                weekClosed: '0k',
                week: 47
            },
            fusion: {
                actualBooking: 0,
                openPipeline: 0,
                yearTarget: 4725000,
                name: 'Fusion',
                weekClosed: '0k',
                week: 47
            },
            radiationoncology: {
                actualBooking: 0,
                openPipeline: 0,
                yearTarget: 4500000,
                name: 'Radiation Oncology',
                weekClosed: '0k',
                week: 47
            },
            semiconductor: {
                actualBooking: 0,
                openPipeline: 0,
                yearTarget: 2000000,
                name: 'Semiconductor',
                weekClosed: '0k',
                week: 47
            },
            quantum: {
                actualBooking: 0,
                openPipeline: 0,
                yearTarget: 1500000,
                name: 'Quantum',
                weekClosed: '0k',
                week: 47
            },
            other: {
                actualBooking: 0,
                openPipeline: 0,
                yearTarget: 1500000,
                name: 'Other',
                weekClosed: '0k',
                week: 47
            }
        };

        // Calculate derived values for initial domain
        const fyProgress = calculateFYProgress();
        const initialData = domainData.accelerator;
        const initialTodayTarget = initialData.yearTarget * fyProgress.ratio;
        const initialRightEdge = Math.max(initialData.actualBooking, initialData.yearTarget);

        let currentValue = initialData.actualBooking;
        let targetValue = initialData.actualBooking;
        let currentTodayTarget = initialTodayTarget;
        let currentYearTarget = initialData.yearTarget;
        let currentRightEdge = initialRightEdge;
        let currentDomain = 'accelerator';

        // Salesforce colors
        const colors = {
            red: '#ea001e',
            green: '#06a59a',
            darkGray: '#706e6b',
            darkBlue: '#0176d3'
        };

        // Update speedometer title with domain and date
        function updateSpeedometerTitle() {
            const domainName = currentDomain.charAt(0).toUpperCase() + currentDomain.slice(1);
            const dateStr = calculationDate.toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            });
            const titleElement = document.getElementById('speedometerTitle');
            titleElement.innerHTML =
                `<div style="line-height: 1.3;">${domainName}</div>
                 <div style="font-size: 0.7em; font-weight: 400; color: #706e6b; margin-top: 2px;">Booking progress on ${dateStr}</div>`;
        }

        function drawSpeedometer() {
            // Update title
            updateSpeedometerTitle();
            // Recalculate center based on current canvas dimensions
            const rect = canvas.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height - 50;
            const radius = Math.min(rect.width, rect.height * 2) * 0.28; // Responsive radius

            ctx.clearRect(0, 0, rect.width, rect.height);

            const startAngle = Math.PI;
            const endAngle = Math.PI * 2;
            const totalAngle = Math.PI;

            // Calculate angles based on rightEdge (max of booking vs yearTarget)
            const todayRatio = currentTodayTarget / currentRightEdge;
            const todayAngle = startAngle + (totalAngle * todayRatio);

            // Red segment (0 to today's target)
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, startAngle, todayAngle);
            ctx.lineWidth = 55;
            ctx.strokeStyle = colors.red;
            ctx.lineCap = 'round';  // Rounded edge like green segment
            ctx.stroke();

            // Green segment (today's target to right edge)
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, todayAngle, endAngle);
            ctx.lineWidth = 55;
            ctx.strokeStyle = colors.green;
            ctx.lineCap = 'round';
            ctx.stroke();

            // Draw CLEAR BOUNDARY LINE at today's target position
            const boundaryLineInner = radius - 25;
            const boundaryLineOuter = radius + 30;
            const bx1 = centerX + Math.cos(todayAngle) * boundaryLineInner;
            const by1 = centerY + Math.sin(todayAngle) * boundaryLineInner;
            const bx2 = centerX + Math.cos(todayAngle) * boundaryLineOuter;
            const by2 = centerY + Math.sin(todayAngle) * boundaryLineOuter;

            ctx.beginPath();
            ctx.moveTo(bx1, by1);
            ctx.lineTo(bx2, by2);
            ctx.lineWidth = 3;
            ctx.strokeStyle = colors.darkBlue;
            ctx.stroke();

            // Add a marker circle at the boundary - FURTHER OUT
            const markerRadius = radius + 95;
            const markerX = centerX + Math.cos(todayAngle) * markerRadius;
            const markerY = centerY + Math.sin(todayAngle) * markerRadius;

            // Draw dashed line connecting boundary line to marker circle
            ctx.beginPath();
            ctx.moveTo(bx2, by2);
            ctx.lineTo(markerX, markerY);
            ctx.lineWidth = 2;
            ctx.strokeStyle = colors.darkBlue;
            ctx.setLineDash([5, 5]); // 5px dash, 5px gap
            ctx.stroke();
            ctx.setLineDash([]); // Reset to solid line

            ctx.beginPath();
            ctx.arc(markerX, markerY, 8, 0, 2 * Math.PI);
            ctx.fillStyle = colors.darkBlue;
            ctx.fill();

            ctx.beginPath();
            ctx.arc(markerX, markerY, 5, 0, 2 * Math.PI);
            ctx.fillStyle = 'white';
            ctx.fill();

            // Add "Current Target: ‚Ç¨X.XM" label - positioned to be visible even at middle of scale
            const labelX = markerX;
            // Position label based on angle - if near horizontal middle, move it further up
            const angleDeg = (todayAngle * 180 / Math.PI);
            let labelOffset = -25; // default offset for visibility

            // If angle is near horizontal (around 0 degrees or 180 degrees), move label further
            if (Math.abs(angleDeg) < 30 || Math.abs(angleDeg - 180) < 30) {
                labelOffset = -35; // move further away when near horizontal
            }

            const labelY = markerY + labelOffset;

            ctx.fillStyle = colors.darkBlue;
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Draw label text "Current Target:" and value separately for larger number
            const labelText = 'Current Target: ';
            const valueText = formatValue(currentTodayTarget);

            // Measure text widths to position them
            const labelWidth = ctx.measureText(labelText).width;
            const valueWidth = ctx.measureText(valueText).width;
            const totalWidth = labelWidth + valueWidth;

            // Draw label text
            ctx.font = 'bold 12px Arial';
            ctx.fillText(labelText, labelX - valueWidth/2, labelY);

            // Draw value in larger font
            ctx.font = 'bold 14px Arial';
            ctx.fillText(valueText, labelX + labelWidth/2, labelY);

            // Draw ALL tick marks and labels AFTER arc (so they appear on top)
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const numTicks = 11;
            for (let i = 0; i <= numTicks; i++) {
                const ratio = i / numTicks;
                const angle = startAngle + (totalAngle * ratio);
                const value = (currentRightEdge * ratio);
                
                // Small tick mark
                const tickInner = radius + 24;
                const tickOuter = radius + 30;
                
                const x1 = centerX + Math.cos(angle) * tickInner;
                const y1 = centerY + Math.sin(angle) * tickInner;
                const x2 = centerX + Math.cos(angle) * tickOuter;
                const y2 = centerY + Math.sin(angle) * tickOuter;

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.lineWidth = 2;
                ctx.strokeStyle = colors.darkGray;
                ctx.stroke();

                // Label even FURTHER outside
                const labelRadius = radius + 60;
                const labelX = centerX + Math.cos(angle) * labelRadius;
                const labelY = centerY + Math.sin(angle) * labelRadius;
                
                // Edge labels are BOLD and BIGGER
                if (i === 0 || i === numTicks) {
                    ctx.fillStyle = '#000000';
                    ctx.font = 'bold 18px Arial';
                    
                    if (i === 0) {
                        ctx.fillText('‚Ç¨0', labelX, labelY);
                    } else {
                        // currentRightEdge is in raw numbers (e.g., 4500000)
                        if (currentRightEdge >= 1000000) {
                            ctx.fillText('‚Ç¨' + (currentRightEdge / 1000000).toFixed(1) + 'M', labelX, labelY);
                        } else {
                            ctx.fillText('‚Ç¨' + Math.round(currentRightEdge / 1000) + 'k', labelX, labelY);
                        }
                    }
                } else {
                    // Middle values
                    ctx.fillStyle = colors.darkGray;
                    ctx.font = '13px Arial';
                    
                    // value is in raw numbers
                    if (value >= 1000000) {
                        ctx.fillText('‚Ç¨' + (value / 1000000).toFixed(1) + 'M', labelX, labelY);
                    } else {
                        ctx.fillText('‚Ç¨' + Math.round(value / 1000) + 'k', labelX, labelY);
                    }
                }
            }

            // Needle - pointing outward (Salesforce style: wide base, sharp point)
            // Needle shows current booking relative to right edge
            const needleRatio = Math.min(Math.max(currentValue, 0) / currentRightEdge, 1);
            const needleAngle = startAngle + (totalAngle * needleRatio);
            const needleLength = radius + 10;

            const needleEndX = centerX + Math.cos(needleAngle) * needleLength;
            const needleEndY = centerY + Math.sin(needleAngle) * needleLength;

            // Draw needle as triangle: wide base at center, sharp point at end
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(needleAngle);

            ctx.beginPath();
            ctx.moveTo(needleLength, 0); // Sharp point at the end
            ctx.lineTo(0, -8); // Wide base left side
            ctx.lineTo(0, 8); // Wide base right side
            ctx.closePath();
            ctx.fillStyle = '#000000';
            ctx.fill();

            ctx.restore();

            // Center circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, 10, 0, 2 * Math.PI);
            ctx.fillStyle = '#000000';
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, 5, 0, 2 * Math.PI);
            ctx.fillStyle = 'white';
            ctx.fill();

            // –ü—Ä–∏–º–µ–Ω–∏—Ç—å –∞–Ω–∏–º–∞—Ü–∏—é –µ—Å–ª–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ > 100%
            const percentage = (currentValue / currentTodayTarget) * 100;
            if (percentage > 100) {
                canvas.classList.add('speedometer-celebration');
            } else {
                canvas.classList.remove('speedometer-celebration');
            }
        }

        function formatValue(value) {
            // Value comes in as raw number (e.g., 450000)
            if (value >= 1000000) {
                return '‚Ç¨' + (value / 1000000).toFixed(1) + 'M';
            } else if (value >= 1000) {
                return '‚Ç¨' + (value / 1000).toFixed(1) + 'k';
            } else {
                return '‚Ç¨' + Math.round(value);
            }
        }

        function animate() {
            if (Math.abs(currentValue - targetValue) < 0.01) {
                currentValue = targetValue;
                drawSpeedometer();
                document.getElementById('valueDisplay').textContent = formatValue(currentValue);
                // Calculate percentage based on YEAR target (not today's target)
                const percentage = Math.round((currentValue / currentYearTarget) * 100);
                document.getElementById('percentDisplay').textContent = `(${percentage}%)`;
                return;
            }

            const diff = targetValue - currentValue;
            currentValue += diff * 0.1;
            drawSpeedometer();
            document.getElementById('valueDisplay').textContent = formatValue(currentValue);
            const percentage = Math.round((currentValue / currentYearTarget) * 100);
            document.getElementById('percentDisplay').textContent = `(${percentage}%)`;
            requestAnimationFrame(animate);
        }

        function switchDomain(domain) {
            // Update active button
            document.querySelectorAll('.slds-button').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent === domainData[domain]?.name ||
                    (domain === 'overall' && btn.textContent === 'All Domains')) {
                    btn.classList.add('active');
                }
            });

            currentDomain = domain;
            const data = domainData[domain];
            
            // Calculate derived values
            const fyProgress = calculateFYProgress();
            const todayTarget = data.yearTarget * fyProgress.ratio;
            const rightEdge = Math.max(data.actualBooking, data.yearTarget);
            
            targetValue = data.actualBooking;
            currentTodayTarget = todayTarget;
            currentYearTarget = data.yearTarget;
            currentRightEdge = rightEdge;
            
            // Get week range
            const weekRange = getWeekRange(calculationDate);
            
            document.getElementById('domainTitle').textContent = data.name;
            document.getElementById('weekInfo').textContent = `Closed in week [${weekRange}] = ${data.weekClosed}`;
            document.getElementById('targetInfo').textContent = `Target for Week [${weekRange}] = ${formatValue(todayTarget)}`;

            // Update speedometer header - only domain name
            document.getElementById('speedometerTitle').textContent = data.name;
            
            const now = new Date();
            document.getElementById('dateInfo').textContent = `As of ${now.getDate()}. ${now.toLocaleString('en', {month: 'short'})}. ${now.getFullYear()}, ${now.getHours()}:${String(now.getMinutes()).padStart(2, '0')}`;
            
            animate();
            drawBarChart();
        }

        // Load CSV file
        // Parse European date format: "28. 11. 2025, 15:34" or "28. 11. 2025" or "31. 01. 2026"
        function parseEuropeanDate(dateStr) {
            if (!dateStr) return null;
            
            const trimmed = dateStr.trim().replace(/^"|"$/g, ''); // Remove quotes and trim
            if (trimmed === '') return null;
            
            // Remove time part if present
            const datePart = trimmed.split(',')[0].trim();
            
            // Parse "DD. MM. YYYY" or "D. M. YYYY"
            const parts = datePart.split('.').map(p => p.trim()).filter(p => p !== '');
            if (parts.length < 3) return null;
            
            const day = parseInt(parts[0]);
            const month = parseInt(parts[1]);
            const year = parseInt(parts[2]);
            
            if (isNaN(day) || isNaN(month) || isNaN(year)) return null;
            if (day < 1 || day > 31 || month < 1 || month > 12) return null;

            // Return Date object
            return new Date(year, month - 1, day); // month is 0-indexed in Date constructor
        }

        // Parse European/US number format: "EUR20,000.00" or "2.000.000,00 ‚Ç¨" ‚Üí number
        function parseEuropeanAmount(amountStr) {
            if (!amountStr || amountStr.trim() === '') return 0;
            
            // Remove quotes, currency symbols, carriage returns
            let cleaned = amountStr.trim()
                .replace(/\r/g, '')
                .replace(/^["']|["']$/g, '')  // Remove surrounding quotes
                .replace(/EUR|‚Ç¨|\$/gi, '')     // Remove currency symbols
                .replace(/\s+/g, '');          // Remove all whitespace
            
            if (!cleaned) return 0;
            
            // Detect format based on separators
            const hasComma = cleaned.includes(',');
            const hasDot = cleaned.includes('.');
            
            if (hasComma && hasDot) {
                // Both separators present - determine which is decimal
                const lastComma = cleaned.lastIndexOf(',');
                const lastDot = cleaned.lastIndexOf('.');
                
                if (lastComma > lastDot) {
                    // European: 2.000.000,50 (dot=thousands, comma=decimal)
                    cleaned = cleaned.replace(/\./g, '').replace(',', '.');
                } else {
                    // US: 2,000,000.50 (comma=thousands, dot=decimal)
                    cleaned = cleaned.replace(/,/g, '');
                }
            } else if (hasComma && !hasDot) {
                // Only comma
                const commaPos = cleaned.indexOf(',');
                const afterComma = cleaned.substring(commaPos + 1);
                
                if (afterComma.length === 2) {
                    // Likely decimal: 20,50
                    cleaned = cleaned.replace(',', '.');
                } else {
                    // Likely thousands: 20,000
                    cleaned = cleaned.replace(/,/g, '');
                }
            } else if (hasDot && !hasComma) {
                // Only dot - assume US decimal format: 20.50 or thousands: 20.000
                // If 2 digits after dot, it's decimal
                const dotPos = cleaned.indexOf('.');
                const afterDot = cleaned.substring(dotPos + 1);
                
                if (afterDot.length === 3) {
                    // Likely European thousands: 20.000
                    cleaned = cleaned.replace(/\./g, '');
                }
                // Otherwise keep dot as decimal
            }
            
            const value = parseFloat(cleaned);
            return isNaN(value) ? 0 : value;
        }

        // ========================================================================
        // Load current pipeline from Salesforce
        function loadCurrentPipeline(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                parseCurrentPipeline(text);
            };
            reader.readAsText(file);
        }

        // Load field history from Salesforce
        function loadFieldHistory(event) {
            console.log('üîç loadFieldHistory() CALLED');
            const file = event.target.files[0];
            if (!file) {
                console.log('‚ùå No file selected');
                return;
            }

            console.log('üìÅ File selected:', file.name);
            const reader = new FileReader();
            reader.onload = function(e) {
                console.log('üìñ File read successfully, parsing...');
                const text = e.target.result;
                parseFieldHistory(text);
            };
            reader.readAsText(file);
        }

        // Parse current pipeline CSV
        function parseCurrentPipeline(text) {
            console.log('=== parseCurrentPipeline called ===');
            console.log('Text length:', text.length);

            // Handle both \r\n and \n line endings
            const lines = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').trim().split('\n');
            const headers = parseCSVLine(lines[0]);

            console.log('CSV Headers:', headers);
            console.log('CSV Lines:', lines.length);
            console.log('Opportunity Domain at index:', headers.indexOf('Opportunity Domain'));

            currentPipelineData = [];
            console.log('Initialized currentPipelineData array');
            
            for (let i = 1; i < lines.length; i++) {
                const values = parseCSVLine(lines[i]);
                
                const opp = {};
                headers.forEach((header, index) => {
                    opp[header] = values[index] ? values[index] : '';
                });
                
                currentPipelineData.push(opp);
                
                // Debug first few rows
                if (i <= 3) {
                    console.log(`Row ${i} Domain:`, opp['Opportunity Domain']);
                    console.log(`Row ${i} Amount:`, opp['Net Amount'], '‚Üí', parseEuropeanAmount(opp['Net Amount']));
                    console.log(`Row ${i} CloseDate:`, opp['Close Date'], '‚Üí', parseEuropeanDate(opp['Close Date']));
                }
            }
            
            document.getElementById('fileStatus').textContent =
                `‚úì Loaded ${currentPipelineData.length} opportunities from current pipeline`;
            document.getElementById('fileStatus').style.color = '#2e844a';

            console.log(`‚úì Loaded ${currentPipelineData.length} opportunities`);
            console.log('currentPipelineData is now:', currentPipelineData ? 'NOT NULL' : 'NULL');
            console.log('fieldHistoryData length:', fieldHistoryData ? fieldHistoryData.length : 'null');

            // Render Q1 Outlook
            renderQ1Outlook();

            // If both files loaded, generate snapshots
            if (currentPipelineData && fieldHistoryData.length > 0) {
                console.log('Both files loaded - calling generateSnapshots()');
                generateSnapshots();
            } else {
                console.log('Not calling generateSnapshots - missing data');
                console.log('  currentPipelineData:', currentPipelineData ? 'exists' : 'missing');
                console.log('  fieldHistoryData:', fieldHistoryData.length > 0 ? 'exists' : 'missing');
            }
            console.log('=== parseCurrentPipeline completed ===');
        }

        // Parse field history CSV
        function parseFieldHistory(text) {
            console.log('=== parseFieldHistory called ===');
            console.log('Text length:', text.length);

            // Handle both \r\n and \n line endings
            const lines = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').trim().split('\n');
            const headers = parseCSVLine(lines[0]);

            console.log('Field History Headers:', headers);
            console.log('Field History Lines:', lines.length);

            fieldHistoryData = [];

            for (let i = 1; i < lines.length; i++) {
                const values = parseCSVLine(lines[i]);

                const record = {};
                headers.forEach((header, index) => {
                    record[header] = values[index] ? values[index] : '';
                });

                fieldHistoryData.push(record);
            }

            document.getElementById('fileStatus').textContent =
                `‚úì Loaded ${fieldHistoryData.length} field history records`;
            document.getElementById('fileStatus').style.color = '#2e844a';

            console.log(`‚úì Loaded ${fieldHistoryData.length} history records`);
            console.log('currentPipelineData:', currentPipelineData ? currentPipelineData.length : 'null');
            console.log('fieldHistoryData:', fieldHistoryData.length);

            console.log('üîç CHECKPOINT: About to check if both files loaded');
            console.log('üîç currentPipelineData exists?', !!currentPipelineData);
            console.log('üîç fieldHistoryData.length > 0?', fieldHistoryData.length > 0);

            // If both files loaded, generate snapshots
            if (currentPipelineData && fieldHistoryData.length > 0) {
                console.log('‚úÖ Both files ready - calling tests and generateSnapshots()');

                // AUTO-TEST: Run Close Date history analysis
                console.log('\nüß™ RUNNING CLOSE DATE HISTORY ANALYSIS...\n');
                try {
                    testCloseDateHistory();
                } catch (error) {
                    console.error('‚ùå Error in testCloseDateHistory:', error);
                }

                // Populate Close Date Changes table
                try {
                    populateCloseDateChangesTable();
                } catch (error) {
                    console.error('‚ùå Error in populateCloseDateChangesTable:', error);
                }

                // Populate Open Opportunities Close Date Changes table
                try {
                    populateOpenCloseDateChangesTable();
                } catch (error) {
                    console.error('‚ùå Error in populateOpenCloseDateChangesTable:', error);
                }

                generateSnapshots();
            } else {
                console.log('Not calling generateSnapshots - missing data');
                console.log('  currentPipelineData:', currentPipelineData ? 'exists' : 'NULL');
                console.log('  fieldHistoryData:', fieldHistoryData.length > 0 ? 'exists' : 'EMPTY');
                
                // If presentation already started, update tables
                if (currentPipelineData && currentPipelineData.length > 0 && typeof domainData !== 'undefined' && domainData) {
                    console.log('üìä Presentation started - updating tables with field history');
                    populateProgressTracking();
                }
            }
            console.log('=== parseFieldHistory completed ===');
        }

        // Parse CSV line handling quoted values with semicolons (RFC 4180 compliant)
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            let i = 0;

            while (i < line.length) {
                const char = line[i];
                const nextChar = i + 1 < line.length ? line[i + 1] : null;

                if (inQuotes) {
                    if (char === '"') {
                        if (nextChar === '"') {
                            // Escaped quote "" -> "
                            current += '"';
                            i += 2;
                            continue;
                        } else {
                            // End of quoted field
                            inQuotes = false;
                            i++;
                            continue;
                        }
                    } else {
                        // Inside quotes, add everything
                        current += char;
                        i++;
                    }
                } else {
                    // Not in quotes
                    if (char === '"') {
                        // Start of quoted field
                        inQuotes = true;
                        i++;
                    } else if (char === ';') {
                        // Field separator (semicolon for European CSV format)
                        result.push(current.trim());
                        current = '';
                        i++;
                    } else if (char === '\r' || char === '\n') {
                        // End of line
                        break;
                    } else {
                        // Regular character
                        current += char;
                        i++;
                    }
                }
            }

            // Add last field
            result.push(current.trim());

            return result;
        }

        // Generate weekly snapshots from current pipeline + field history
        function generateSnapshots() {
            console.log('=== generateSnapshots called ===');
            snapshotData = [];
            existingRecords = new Set();
            
            // Get today's date as snapshot date
            const today = new Date();
            const snapshotDate = today.toISOString().split('T')[0];
            
            let validOpps = 0;
            let skippedOpps = 0;
            
            // Convert current pipeline to snapshot format
            currentPipelineData.forEach((opp, index) => {
                const domain = opp['Opportunity Domain'] || opp['Domain'] || 'Other'; // Default to Other if no domain
                
                const rawAmount = opp['Net Amount'];
                const parsedAmount = parseEuropeanAmount(rawAmount);
                const rawCloseDate = opp['Close Date'];
                const parsedCloseDate = parseEuropeanDate(rawCloseDate);
                
                // Debug first 3 opportunities
                if (index < 3) {
                    console.log(`\n--- Opportunity ${index + 1}: ${opp['Opportunity Name']} ---`);
                    console.log('Domain:', domain);
                    console.log('Stage:', opp['Stage']);
                    console.log('Raw Amount:', rawAmount, '‚Üí Parsed:', parsedAmount);
                    console.log('Raw Close Date:', rawCloseDate, '‚Üí Parsed:', parsedCloseDate);
                }
                
                const snapshot = {
                    OpportunityID: opp['Opportunity ID'] || opp['OpportunityID'],
                    OpportunityName: opp['Opportunity Name'],
                    Amount: parsedAmount,
                    Stage: opp['Stage'],
                    CloseDate: parsedCloseDate,
                    Domain: domain,
                    Owner: opp['Opportunity Owner'] || opp['Owner'],
                    DomainEngagement: opp['Domain Engagement'] || '',
                    SnapshotDate: snapshotDate
                };
                
                snapshotData.push(snapshot);
                validOpps++;
                
                const fingerprint = getRecordFingerprint(snapshot, snapshotDate);
                existingRecords.add(fingerprint);
            });
            
            console.log(`‚úì Created ${validOpps} snapshots, skipped ${skippedOpps} without domain`);
            
            // TODO: Reconstruct historical snapshots from field history
            // For now, we only have current week snapshot
            
            // Update available weeks
            const weekSet = new Set(snapshotData.map(s => s.SnapshotDate));
            availableWeeks = Array.from(weekSet).sort();
            
            document.getElementById('fileStatus').textContent = 
                `‚úì Generated ${snapshotData.length} snapshots (${skippedOpps} skipped - no domain)\nüìÖ Current week only (history reconstruction: TODO)`;
            document.getElementById('fileStatus').style.color = '#2e844a';
            
            console.log(`‚úì Generated ${snapshotData.length} snapshots across ${availableWeeks.length} weeks`);
            console.log('First 3 snapshots:', snapshotData.slice(0, 3));
            
            // Load latest week data
            const latestWeek = availableWeeks[availableWeeks.length - 1];
            opportunityData = snapshotData.filter(s => s.SnapshotDate === latestWeek);
            
            console.log(`opportunityData has ${opportunityData.length} records`);
            console.log('First opportunity:', opportunityData[0]);

            domainData = aggregateDomainData();

            console.log('domainData:', domainData);

            // Show presentation overlay - wait for user to start
            showPresentationStartOverlay();
        }

        // ========================================================================
        // TEST: Show all Close Date history for Closed Won opportunities
        // ========================================================================
        
        function testCloseDateHistory() {
            console.log('üîç testCloseDateHistory() CALLED');
            console.log('\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
            console.log('‚ïë  CLOSE DATE HISTORY - CLOSED WON OPPORTUNITIES       ‚ïë');
            console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n');

            console.log('currentPipelineData exists:', !!currentPipelineData);
            console.log('currentPipelineData length:', currentPipelineData ? currentPipelineData.length : 0);
            console.log('fieldHistoryData exists:', !!fieldHistoryData);
            console.log('fieldHistoryData length:', fieldHistoryData ? fieldHistoryData.length : 0);

            if (!currentPipelineData || currentPipelineData.length === 0) {
                console.log('‚ùå No currentPipelineData available');
                return;
            }

            if (!fieldHistoryData || fieldHistoryData.length === 0) {
                console.log('‚ùå No fieldHistoryData available');
                return;
            }
            
            // Get all Closed Won opportunities
            const closedWon = currentPipelineData.filter(opp => 
                opp['Stage'] === 'Closed Won'
            );
            
            console.log(`Found ${closedWon.length} Closed Won opportunities\n`);
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
            
            closedWon.forEach((opp, index) => {
                const oppId = opp['Opportunity ID'];
                const oppName = opp['Opportunity Name'];
                
                // Find all Close Date changes for this opportunity
                const closeDateChanges = fieldHistoryData
                    .filter(record => 
                        record['Opportunity ID'] === oppId &&
                        record['Field / Event'] === 'Close Date'
                    )
                    .map(record => ({
                        date: record['Edit Date'],
                        newValue: record['New Value'],
                        oldValue: record['Old Value']
                    }))
                    .sort((a, b) => {
                        const dateA = parseEuropeanDate(a.date);
                        const dateB = parseEuropeanDate(b.date);
                        return new Date(dateA) - new Date(dateB);
                    });
                
                console.log(`${index + 1}. ${oppName}`);
                console.log(`   Opportunity ID: ${oppId}`);
                console.log(`   Current Close Date: ${opp['Close Date']}`);
                console.log(`   Total Close Date changes: ${closeDateChanges.length}`);
                
                if (closeDateChanges.length > 0) {
                    console.log(`   \n   üìÖ All New Close Dates (chronologically):`);
                    closeDateChanges.forEach((change, i) => {
                        console.log(`      ${i + 1}. ${change.date}: "${change.oldValue}" ‚Üí "${change.newValue}"`);
                    });
                } else {
                    console.log(`   ‚ö†Ô∏è No Close Date changes found in history`);
                }
                
                console.log('\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n');
            });
            
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log(`‚úì Analysis complete for ${closedWon.length} opportunities`);
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
        }

        // ========================================================================
        // POPULATE CLOSE DATE CHANGES TABLE
        // ========================================================================

        function populateCloseDateChangesTable() {
            console.log('üîç populateCloseDateChangesTable() CALLED');

            if (!currentPipelineData || currentPipelineData.length === 0) {
                console.log('‚ùå No currentPipelineData available');
                return;
            }

            if (!fieldHistoryData || fieldHistoryData.length === 0) {
                console.log('‚ùå No fieldHistoryData available');
                return;
            }

            // Get all Closed Won opportunities
            const closedWon = currentPipelineData.filter(opp =>
                opp['Stage'] === 'Closed Won'
            );

            console.log(`Found ${closedWon.length} Closed Won opportunities`);

            const tableData = [];

            closedWon.forEach(opp => {
                const oppId = opp['Opportunity ID'];
                const oppName = opp['Opportunity Name'];
                const owner = opp['Opportunity Owner'] || opp['Owner'] || opp['Account Owner'] || 'N/A';
                const currentCloseDate = opp['Close Date'];
                const currentAmount = parseEuropeanAmount(opp['Net Amount']);

                // Find all Close Date changes for this opportunity
                const closeDateChanges = fieldHistoryData
                    .filter(record =>
                        record['Opportunity ID'] === oppId &&
                        record['Field / Event'] === 'Close Date'
                    )
                    .map(record => ({
                        date: record['Edit Date'],
                        newValue: record['New Value'],
                        oldValue: record['Old Value']
                    }))
                    .sort((a, b) => {
                        const dateA = parseEuropeanDate(a.date);
                        const dateB = parseEuropeanDate(b.date);
                        return new Date(dateA) - new Date(dateB);
                    });

                // Find all Amount changes for this opportunity (check both 'Net Amount' and 'Amount' fields)
                const amountChanges = fieldHistoryData
                    .filter(record =>
                        record['Opportunity ID'] === oppId &&
                        (record['Field / Event'] === 'Net Amount' || record['Field / Event'] === 'Amount')
                    )
                    .map(record => ({
                        date: record['Edit Date'],
                        newValue: parseEuropeanAmount(record['New Value']),
                        oldValue: parseEuropeanAmount(record['Old Value'])
                    }))
                    .sort((a, b) => {
                        const dateA = parseEuropeanDate(a.date);
                        const dateB = parseEuropeanDate(b.date);
                        return new Date(dateA) - new Date(dateB);
                    });

                // Initial close date is the first "New Value" in the history
                const initialCloseDate = closeDateChanges.length > 0 ? closeDateChanges[0].newValue : currentCloseDate;

                // Initial amount is the first "New Value" in the history, or current if no history
                const initialAmount = amountChanges.length > 0 ? amountChanges[0].newValue : currentAmount;

                // Calculate slippage (difference in days between initial and final)
                let slippageDays = 0;
                if (initialCloseDate && currentCloseDate) {
                    const initialDate = parseEuropeanDate(initialCloseDate);
                    const finalDate = parseEuropeanDate(currentCloseDate);
                    if (initialDate && finalDate) {
                        const diff = new Date(finalDate) - new Date(initialDate);
                        slippageDays = Math.round(diff / (1000 * 60 * 60 * 24));
                    }
                }

                tableData.push({
                    oppId: oppId,
                    oppName: oppName,
                    owner: owner,
                    initialCloseDate: initialCloseDate,
                    changesCount: closeDateChanges.length,
                    slippageDays: slippageDays,
                    finalCloseDate: currentCloseDate,
                    initialAmount: initialAmount,
                    finalAmount: currentAmount
                });
            });

            // Calculate changePercent for each item (needed for sorting)
            tableData.forEach(item => {
                item.changePercent = item.initialAmount > 0
                    ? ((item.finalAmount - item.initialAmount) / item.initialAmount) * 100
                    : 0;
            });

            // Group by owner
            const groupedByOwner = {};
            tableData.forEach(item => {
                if (!groupedByOwner[item.owner]) {
                    groupedByOwner[item.owner] = [];
                }
                groupedByOwner[item.owner].push(item);
            });

            // Sort owners alphabetically
            const sortedOwners = Object.keys(groupedByOwner).sort();

            // Sort opportunities within each owner group
            sortedOwners.forEach(owner => {
                groupedByOwner[owner].sort((a, b) => {
                    // Category sorting: 1=decreased, 2=increased, 3=no change
                    const catA = a.changePercent < -1 ? 1 : (a.changePercent > 1 ? 2 : 3);
                    const catB = b.changePercent < -1 ? 1 : (b.changePercent > 1 ? 2 : 3);

                    if (catA !== catB) return catA - catB;

                    // Within category sorting
                    if (catA === 1) return a.changePercent - b.changePercent; // decreases: most negative first
                    if (catA === 2) return b.changePercent - a.changePercent; // increases: most positive first
                    return b.slippageDays - a.slippageDays; // no change: by slippage descending
                });
            });

            // Populate table
            const tbody = document.getElementById('closeDateChangesBody');
            const summary = document.getElementById('closeDateChangesSummary');

            if (tableData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="10" style="text-align: center; color: #706e6b;">No Closed Won opportunities found</td></tr>';
                summary.textContent = '(0 opportunities)';
                return;
            }

            summary.textContent = `(${tableData.length} opportunities, ${sortedOwners.length} owners)`;

            // Format amount helper
            const formatAmount = (amount) => {
                if (amount >= 1000000) {
                    return '‚Ç¨' + (amount / 1000000).toFixed(1) + 'M';
                } else if (amount >= 1000) {
                    return '‚Ç¨' + (amount / 1000).toFixed(1) + 'k';
                } else {
                    return '‚Ç¨' + Math.round(amount);
                }
            };

            let html = '';
            let globalIndex = 1;

            // Build HTML with groups and subtotals
            sortedOwners.forEach((owner, ownerIdx) => {
                const opps = groupedByOwner[owner];

                // Calculate subtotal for this owner
                const subtotalInitialAmount = opps.reduce((sum, item) => sum + item.initialAmount, 0);
                const subtotalFinalAmount = opps.reduce((sum, item) => sum + item.finalAmount, 0);
                const subtotalAvgChanges = (opps.reduce((sum, item) => sum + item.changesCount, 0) / opps.length).toFixed(1);
                const subtotalAvgSlippage = (opps.reduce((sum, item) => sum + item.slippageDays, 0) / opps.length).toFixed(1);
                const subtotalDeltaPercent = subtotalInitialAmount > 0
                    ? (((subtotalFinalAmount - subtotalInitialAmount) / subtotalInitialAmount) * 100).toFixed(1)
                    : 0;

                // Determine subtotal row color based on delta %
                let subtotalBgColor = '#f3f2f2'; // default gray
                if (subtotalDeltaPercent > 5) {
                    subtotalBgColor = '#e8f5e9'; // light green
                } else if (subtotalDeltaPercent < -5) {
                    subtotalBgColor = '#ffebee'; // light red
                }

                const subtotalSlippageColor = subtotalAvgSlippage > 0 ? '#c23934' : (subtotalAvgSlippage < 0 ? '#2e844a' : '#706e6b');

                // Subtotal row (clickable to toggle group)
                html += `
                    <tr class="owner-subtotal-row" onclick="toggleOwnerGroup(${ownerIdx})" style="background-color: ${subtotalBgColor}; font-weight: bold; cursor: pointer; border-top: 2px solid #dddbda;">
                        <td style="text-align: center;"><span class="toggle-icon" id="toggle-icon-${ownerIdx}">‚ñ∂</span></td>
                        <td colspan="2" style="padding-left: 8px;">${owner} (${opps.length} opps)</td>
                        <td></td>
                        <td style="text-align: right;">${formatAmount(subtotalInitialAmount)}</td>
                        <td style="text-align: center; color: #0176d3;">${subtotalAvgChanges}</td>
                        <td style="text-align: center; color: ${subtotalSlippageColor};">${subtotalAvgSlippage > 0 ? '+' : ''}${subtotalAvgSlippage}</td>
                        <td></td>
                        <td style="text-align: right;">${formatAmount(subtotalFinalAmount)}</td>
                        <td style="text-align: center; color: #0176d3;">${subtotalDeltaPercent}%</td>
                    </tr>
                `;

                // Detail rows for this owner (initially hidden)
                opps.forEach((item) => {
                    // Color slippage
                    let slippageColor = '#706e6b';
                    if (item.slippageDays > 0) slippageColor = '#c23934';
                    else if (item.slippageDays < 0) slippageColor = '#2e844a';

                    // Calculate amount change display
                    let amountChangeDisplay = '';
                    let rowHighlight = '';
                    if (Math.abs(item.changePercent) < 1) {
                        amountChangeDisplay = '‚àí';
                    } else {
                        const percentText = item.changePercent.toFixed(1) + '%';
                        if (item.changePercent > 1) {
                            amountChangeDisplay = '<span style="color: #2e844a; display: inline-block; vertical-align: middle;">‚ñ≤</span> <span style="display: inline-block; vertical-align: middle;">' + percentText + '</span>';
                        } else if (item.changePercent < -1) {
                            amountChangeDisplay = '<span style="color: #c23934; display: inline-block; vertical-align: middle;">‚ñº</span> <span style="display: inline-block; vertical-align: middle;">' + percentText + '</span>';
                        }
                    }

                    // Highlight row if change > 10%
                    if (item.changePercent > 10) {
                        rowHighlight = ' background-color: #e8f5e9;';
                    } else if (item.changePercent < -10) {
                        rowHighlight = ' background-color: #ffebee;';
                    }

                    const sfLink = item.oppId ? `https://cosylab.lightning.force.com/lightning/r/Opportunity/${item.oppId}/view` : '#';
                    const oppNameDisplay = item.oppId ? `<a href="${sfLink}" target="_blank" style="color: #0176d3; text-decoration: none; font-weight: 500;">${item.oppName}</a>` : item.oppName;

                    html += `
                        <tr class="owner-detail-row owner-group-${ownerIdx}" style="display: none;${rowHighlight}">
                            <td style="text-align: center; color: #706e6b;">${globalIndex}</td>
                            <td>${oppNameDisplay}</td>
                            <td style="color: #706e6b; font-size: 11px;">${item.owner}</td>
                            <td>${item.initialCloseDate || 'N/A'}</td>
                            <td style="text-align: right; font-weight: bold;">${formatAmount(item.initialAmount)}</td>
                            <td style="text-align: center; font-weight: bold; color: ${item.changesCount > 0 ? '#c23934' : '#2e844a'};">${item.changesCount}</td>
                            <td style="text-align: center; font-weight: bold; color: ${slippageColor};">${item.slippageDays > 0 ? '+' : ''}${item.slippageDays}</td>
                            <td>${item.finalCloseDate || 'N/A'}</td>
                            <td style="text-align: right; font-weight: bold;">${formatAmount(item.finalAmount)}</td>
                            <td style="text-align: center; font-weight: bold;">${amountChangeDisplay}</td>
                        </tr>
                    `;
                    globalIndex++;
                });
            });

            // Calculate overall averages
            const avgChanges = (tableData.reduce((sum, item) => sum + item.changesCount, 0) / tableData.length).toFixed(1);
            const avgSlippage = (tableData.reduce((sum, item) => sum + item.slippageDays, 0) / tableData.length).toFixed(1);
            const avgSlippageColor = avgSlippage > 0 ? '#c23934' : (avgSlippage < 0 ? '#2e844a' : '#706e6b');
            const totalInitialAmount = tableData.reduce((sum, item) => sum + item.initialAmount, 0);
            const totalFinalAmount = tableData.reduce((sum, item) => sum + item.finalAmount, 0);
            const overallDeltaPercent = totalInitialAmount > 0 ? (((totalFinalAmount - totalInitialAmount) / totalInitialAmount) * 100).toFixed(1) : 0;

            // Add overall total row
            html += `
                <tr style="background-color: #d9edf7; font-weight: bold; border-top: 3px solid #0176d3;">
                    <td colspan="3" style="text-align: right; padding-right: 10px;">OVERALL TOTAL:</td>
                    <td></td>
                    <td style="text-align: right;">${formatAmount(totalInitialAmount)}</td>
                    <td style="text-align: center; color: #0176d3;">${avgChanges}</td>
                    <td style="text-align: center; color: ${avgSlippageColor};">${avgSlippage > 0 ? '+' : ''}${avgSlippage}</td>
                    <td></td>
                    <td style="text-align: right;">${formatAmount(totalFinalAmount)}</td>
                    <td style="text-align: center; color: #0176d3;">${overallDeltaPercent}%</td>
                </tr>
            `;

            tbody.innerHTML = html;
            console.log(`‚úì Populated table with ${tableData.length} opportunities grouped by ${sortedOwners.length} owners`);
        }

        // ========================================================================
        // POPULATE OPEN OPPORTUNITIES CLOSE DATE CHANGES TABLE
        // ========================================================================

        function populateOpenCloseDateChangesTable() {
            console.log('üîç populateOpenCloseDateChangesTable() CALLED');

            if (!currentPipelineData || currentPipelineData.length === 0) {
                console.log('‚ùå No currentPipelineData available');
                return;
            }

            if (!fieldHistoryData || fieldHistoryData.length === 0) {
                console.log('‚ùå No fieldHistoryData available');
                return;
            }

            // Qualified stages
            const qualifiedStages = ['Value Creation', 'A Winning Proposal', 'Obtaining Final Commitment', 'Finalisation'];

            // Get all open opportunities in qualified stages
            const openQualified = currentPipelineData.filter(opp =>
                qualifiedStages.includes(opp['Stage'])
            );

            console.log(`Found ${openQualified.length} open qualified opportunities`);

            const tableData = [];

            openQualified.forEach(opp => {
                const oppId = opp['Opportunity ID'];
                const oppName = opp['Opportunity Name'];
                const owner = opp['Opportunity Owner'] || opp['Owner'] || opp['Account Owner'] || 'N/A';
                const currentCloseDate = opp['Close Date'];
                const currentAmount = parseEuropeanAmount(opp['Net Amount']);

                // Find all Close Date changes for this opportunity
                const closeDateChanges = fieldHistoryData
                    .filter(record =>
                        record['Opportunity ID'] === oppId &&
                        record['Field / Event'] === 'Close Date'
                    )
                    .map(record => ({
                        date: record['Edit Date'],
                        newValue: record['New Value'],
                        oldValue: record['Old Value']
                    }))
                    .sort((a, b) => {
                        const dateA = parseEuropeanDate(a.date);
                        const dateB = parseEuropeanDate(b.date);
                        return new Date(dateA) - new Date(dateB);
                    });

                // Find all Amount changes for this opportunity (check both 'Net Amount' and 'Amount' fields)
                const amountChanges = fieldHistoryData
                    .filter(record =>
                        record['Opportunity ID'] === oppId &&
                        (record['Field / Event'] === 'Net Amount' || record['Field / Event'] === 'Amount')
                    )
                    .map(record => ({
                        date: record['Edit Date'],
                        newValue: parseEuropeanAmount(record['New Value']),
                        oldValue: parseEuropeanAmount(record['Old Value'])
                    }))
                    .sort((a, b) => {
                        const dateA = parseEuropeanDate(a.date);
                        const dateB = parseEuropeanDate(b.date);
                        return new Date(dateA) - new Date(dateB);
                    });

                // Initial close date is the first "New Value" in the history
                const initialCloseDate = closeDateChanges.length > 0 ? closeDateChanges[0].newValue : currentCloseDate;

                // Initial amount is the first "New Value" in the history, or current if no history
                const initialAmount = amountChanges.length > 0 ? amountChanges[0].newValue : currentAmount;

                // Calculate slippage (difference in days between initial and current)
                let slippageDays = 0;
                if (initialCloseDate && currentCloseDate) {
                    const initialDate = parseEuropeanDate(initialCloseDate);
                    const finalDate = parseEuropeanDate(currentCloseDate);
                    if (initialDate && finalDate) {
                        const diff = new Date(finalDate) - new Date(initialDate);
                        slippageDays = Math.round(diff / (1000 * 60 * 60 * 24));
                    }
                }

                tableData.push({
                    oppId: oppId,
                    oppName: oppName,
                    owner: owner,
                    initialCloseDate: initialCloseDate,
                    changesCount: closeDateChanges.length,
                    slippageDays: slippageDays,
                    currentCloseDate: currentCloseDate,
                    initialAmount: initialAmount,
                    currentAmount: currentAmount
                });
            });

            // Sort by owner alphabetically
            tableData.sort((a, b) => a.owner.localeCompare(b.owner));

            // Populate table
            const tbody = document.getElementById('openCloseDateChangesBody');
            const summary = document.getElementById('openCloseDateChangesSummary');

            if (tableData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="10" style="text-align: center; color: #706e6b;">No open qualified opportunities found</td></tr>';
                summary.textContent = '(0 opportunities)';
                return;
            }

            // Group by owner
            const groupedByOwner = {};
            tableData.forEach(item => {
                if (!groupedByOwner[item.owner]) {
                    groupedByOwner[item.owner] = [];
                }
                groupedByOwner[item.owner].push(item);
            });

            const sortedOwners = Object.keys(groupedByOwner).sort();
            summary.textContent = `(${tableData.length} opportunities, ${sortedOwners.length} owners)`;

            // Format amount helper
            const formatAmount = (amount) => {
                if (amount >= 1000000) {
                    return '‚Ç¨' + (amount / 1000000).toFixed(1) + 'M';
                } else if (amount >= 1000) {
                    return '‚Ç¨' + (amount / 1000).toFixed(1) + 'k';
                } else {
                    return '‚Ç¨' + Math.round(amount);
                }
            };

            let html = '';
            let globalIndex = 1;

            // Build HTML with groups and subtotals
            sortedOwners.forEach((owner, ownerIdx) => {
                const opps = groupedByOwner[owner];

                // Calculate subtotal for this owner
                const subtotalInitialAmount = opps.reduce((sum, item) => sum + item.initialAmount, 0);
                const subtotalCurrentAmount = opps.reduce((sum, item) => sum + item.currentAmount, 0);
                const subtotalAvgChanges = (opps.reduce((sum, item) => sum + item.changesCount, 0) / opps.length).toFixed(1);
                const subtotalAvgSlippage = (opps.reduce((sum, item) => sum + item.slippageDays, 0) / opps.length).toFixed(1);
                const subtotalDeltaPercent = subtotalInitialAmount > 0
                    ? (((subtotalCurrentAmount - subtotalInitialAmount) / subtotalInitialAmount) * 100).toFixed(1)
                    : 0;

                // Determine subtotal row color based on delta %
                let subtotalBgColor = '#f3f2f2'; // default gray
                if (subtotalDeltaPercent > 5) {
                    subtotalBgColor = '#e8f5e9'; // light green
                } else if (subtotalDeltaPercent < -5) {
                    subtotalBgColor = '#ffebee'; // light red
                }

                const subtotalSlippageColor = subtotalAvgSlippage > 0 ? '#c23934' : (subtotalAvgSlippage < 0 ? '#2e844a' : '#706e6b');

                // Subtotal row (clickable to toggle group)
                html += `
                    <tr class="owner-subtotal-row" onclick="toggleOpenOwnerGroup(${ownerIdx})" style="background-color: ${subtotalBgColor}; font-weight: bold; cursor: pointer; border-top: 2px solid #dddbda;">
                        <td style="text-align: center;"><span class="toggle-icon" id="toggle-open-icon-${ownerIdx}">‚ñ∂</span></td>
                        <td colspan="2" style="padding-left: 8px;">${owner} (${opps.length} opps)</td>
                        <td></td>
                        <td style="text-align: right;">${formatAmount(subtotalInitialAmount)}</td>
                        <td style="text-align: center; color: #0176d3;">${subtotalAvgChanges}</td>
                        <td style="text-align: center; color: ${subtotalSlippageColor};">${subtotalAvgSlippage > 0 ? '+' : ''}${subtotalAvgSlippage}</td>
                        <td></td>
                        <td style="text-align: right;">${formatAmount(subtotalCurrentAmount)}</td>
                        <td style="text-align: center; color: #0176d3;">${subtotalDeltaPercent}%</td>
                    </tr>
                `;

                // Detail rows for this owner (initially hidden)
                opps.forEach((item) => {
                    // Color slippage
                    let slippageColor = '#706e6b';
                    if (item.slippageDays > 0) slippageColor = '#c23934';
                    else if (item.slippageDays < 0) slippageColor = '#2e844a';

                    // Calculate amount change percentage
                    let amountChangeDisplay = '';
                    let rowHighlight = '';
                    if (item.initialAmount > 0) {
                        const changePercent = ((item.currentAmount - item.initialAmount) / item.initialAmount) * 100;

                        if (Math.abs(changePercent) < 1) {
                            amountChangeDisplay = '‚àí';
                        } else {
                            const percentText = changePercent.toFixed(1) + '%';
                            if (changePercent > 1) {
                                amountChangeDisplay = '<span style="color: #2e844a; display: inline-block; vertical-align: middle;">‚ñ≤</span> <span style="display: inline-block; vertical-align: middle;">' + percentText + '</span>';
                            } else if (changePercent < -1) {
                                amountChangeDisplay = '<span style="color: #c23934; display: inline-block; vertical-align: middle;">‚ñº</span> <span style="display: inline-block; vertical-align: middle;">' + percentText + '</span>';
                            }
                        }

                        // Highlight row if change > 10%
                        if (changePercent > 10) {
                            rowHighlight = ' background-color: #e8f5e9;';
                        } else if (changePercent < -10) {
                            rowHighlight = ' background-color: #ffebee;';
                        }
                    } else {
                        amountChangeDisplay = '‚àí';
                    }

                    const sfLink = item.oppId ? `https://cosylab.lightning.force.com/lightning/r/Opportunity/${item.oppId}/view` : '#';
                    const oppNameDisplay = item.oppId ? `<a href="${sfLink}" target="_blank" style="color: #0176d3; text-decoration: none; font-weight: 500;">${item.oppName}</a>` : item.oppName;

                    html += `
                        <tr class="owner-detail-row open-owner-group-${ownerIdx}" style="display: none;${rowHighlight}">
                            <td style="text-align: center; color: #706e6b;">${globalIndex}</td>
                            <td>${oppNameDisplay}</td>
                            <td style="color: #706e6b; font-size: 11px;">${item.owner}</td>
                            <td>${item.initialCloseDate || 'N/A'}</td>
                            <td style="text-align: right; font-weight: bold;">${formatAmount(item.initialAmount)}</td>
                            <td style="text-align: center; font-weight: bold; color: ${item.changesCount > 0 ? '#c23934' : '#2e844a'};">${item.changesCount}</td>
                            <td style="text-align: center; font-weight: bold; color: ${slippageColor};">${item.slippageDays > 0 ? '+' : ''}${item.slippageDays}</td>
                            <td>${item.currentCloseDate || 'N/A'}</td>
                            <td style="text-align: right; font-weight: bold;">${formatAmount(item.currentAmount)}</td>
                            <td style="text-align: center; font-weight: bold;">${amountChangeDisplay}</td>
                        </tr>
                    `;
                    globalIndex++;
                });
            });

            // Calculate overall totals
            const avgChanges = (tableData.reduce((sum, item) => sum + item.changesCount, 0) / tableData.length).toFixed(1);
            const avgSlippage = (tableData.reduce((sum, item) => sum + item.slippageDays, 0) / tableData.length).toFixed(1);
            const avgSlippageColor = avgSlippage > 0 ? '#c23934' : (avgSlippage < 0 ? '#2e844a' : '#706e6b');
            const totalInitialAmount = tableData.reduce((sum, item) => sum + item.initialAmount, 0);
            const totalCurrentAmount = tableData.reduce((sum, item) => sum + item.currentAmount, 0);
            const overallDeltaPercent = totalInitialAmount > 0 ? (((totalCurrentAmount - totalInitialAmount) / totalInitialAmount) * 100).toFixed(1) : 0;

            // Add overall total row
            html += `
                <tr style="background-color: #d9edf7; font-weight: bold; border-top: 3px solid #0176d3;">
                    <td colspan="3" style="text-align: right; padding-right: 10px;">OVERALL TOTAL:</td>
                    <td></td>
                    <td style="text-align: right;">${formatAmount(totalInitialAmount)}</td>
                    <td style="text-align: center; color: #0176d3;">${avgChanges}</td>
                    <td style="text-align: center; color: ${avgSlippageColor};">${avgSlippage > 0 ? '+' : ''}${avgSlippage}</td>
                    <td></td>
                    <td style="text-align: right;">${formatAmount(totalCurrentAmount)}</td>
                    <td style="text-align: center; color: #0176d3;">${overallDeltaPercent}%</td>
                </tr>
            `;

            tbody.innerHTML = html;
            console.log(`‚úì Populated OPEN table with ${tableData.length} opportunities grouped by ${sortedOwners.length} owners`);
            console.log(`‚úì Populated open opportunities table with ${tableData.length} opportunities`);
        }

        function showPresentationStartOverlay() {
            // Create overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                cursor: pointer;
            `;

            const message = document.createElement('div');
            message.style.cssText = `
                color: white;
                font-size: 48px;
                font-weight: bold;
                text-align: center;
                font-family: Arial, sans-serif;
            `;
            message.innerHTML = 'Press SPACE or Click to Start<br><span style="font-size: 24px; opacity: 0.7; margin-top: 10px; display: block;">Data loaded and ready</span>';

            overlay.appendChild(message);
            document.body.appendChild(overlay);

            const startPresentation = () => {
                overlay.remove();
                document.removeEventListener('keydown', keyHandler);

                // Now show all data on Overall domain
                const firstDomain = 'overall';
                currentDomain = firstDomain;
                const firstData = domainData[firstDomain];

                if (!firstData) {
                    console.error('No domain data found!');
                    return;
                }

                const fyProgress = calculateFYProgress();
                const todayTarget = firstData.yearTarget * fyProgress.ratio;
                const rightEdge = Math.max(firstData.actualBooking, firstData.yearTarget);

                targetValue = firstData.actualBooking;
                currentValue = firstData.actualBooking;
                currentTodayTarget = todayTarget;
                currentRightEdge = rightEdge;
                currentYearTarget = firstData.yearTarget;

                document.getElementById('domainTitle').textContent = firstData.name;
                document.getElementById('valueDisplay').textContent = formatValue(firstData.actualBooking);
                const percentage = Math.round((firstData.actualBooking / firstData.yearTarget) * 100);
                document.getElementById('percentDisplay').textContent = `(${percentage}%)`;

                // Update active button to All Domains
                document.querySelectorAll('.slds-button').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.textContent === 'All Domains') {
                        btn.classList.add('active');
                    }
                });

                // Update period booking info
                updatePeriodBookingInfo();

                drawSpeedometer();
                drawBarChart();
                drawPipelineFunnel();
                drawCumulativeChart();
                populateProgressTracking();
                populateClosingTables();

                // Start green bar animation
                startGreenBarAnimation();
            };

            const keyHandler = (e) => {
                if (e.code === 'Space') {
                    e.preventDefault();
                    startPresentation();
                }
            };

            document.addEventListener('keydown', keyHandler);
            overlay.addEventListener('click', startPresentation);
        }

        // OLD FUNCTIONS - keeping for backwards compatibility
        function loadMasterFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                parseSnapshots(text, true); // true = loading master
                document.getElementById('downloadBtn').disabled = false;
            };
            reader.readAsText(file);
        }

        // Load weekly export (new data to add)
        function loadWeeklyExport(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Extract date from filename or ask user
            const filename = file.name;
            let snapshotDate = extractDateFromFilename(filename);
            
            if (!snapshotDate) {
                snapshotDate = prompt('Enter snapshot date (YYYY-MM-DD):', getCurrentDateString());
                if (!snapshotDate) return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                parseWeeklyExport(text, snapshotDate);
                document.getElementById('downloadBtn').disabled = false;
            };
            reader.readAsText(file);
        }

        // Extract date from filename like "Pipeline_2025-11-28.csv"
        function extractDateFromFilename(filename) {
            const match = filename.match(/(\d{4}-\d{2}-\d{2})/);
            return match ? match[1] : null;
        }

        // Get current date as YYYY-MM-DD
        function getCurrentDateString() {
            const now = new Date();
            return now.toISOString().split('T')[0];
        }

        // Download master snapshots file
        function downloadMasterFile() {
            if (snapshotData.length === 0) {
                alert('No data to download!');
                return;
            }

            // Generate CSV
            const headers = Object.keys(snapshotData[0]);
            let csv = headers.join(',') + '\n';
            
            snapshotData.forEach(row => {
                const values = headers.map(header => {
                    let value = row[header];
                    // Handle values with commas
                    if (typeof value === 'string' && value.includes(',')) {
                        value = `"${value}"`;
                    }
                    return value;
                });
                csv += values.join(',') + '\n';
            });

            // Download
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'snapshots.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);

            alert(`‚úì Downloaded snapshots.csv\n${snapshotData.length} total records across ${availableWeeks.length} weeks`);
        }

        // Toggle upload section visibility
        function toggleUploadSection() {
            const section = document.getElementById('fileUploadSection');
            section.classList.toggle('collapsed');
        }

        // Parse weekly export and add to existing snapshots
        function parseWeeklyExport(text, snapshotDate) {
            const lines = text.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.trim());
            
            let newRecords = 0;
            let duplicates = 0;
            
            // Parse each opportunity from weekly export
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                
                const opp = {};
                headers.forEach((header, index) => {
                    let value = values[index] ? values[index].trim() : '';
                    
                    // Parse Amount as number
                    if (header === 'Amount') {
                        opp[header] = parseFloat(value) || 0;
                    } else {
                        opp[header] = value;
                    }
                });
                
                // Add SnapshotDate
                opp.SnapshotDate = snapshotDate;
                
                // Generate fingerprint for duplicate detection
                const fingerprint = getRecordFingerprint(opp, snapshotDate);
                
                // Check if this exact record already exists
                if (existingRecords.has(fingerprint)) {
                    duplicates++;
                    continue; // Skip duplicate
                }
                
                // Add new record
                existingRecords.add(fingerprint);
                snapshotData.push(opp);
                newRecords++;
            }
            
            // Update available weeks
            const weekSet = new Set(snapshotData.map(s => s.SnapshotDate));
            availableWeeks = Array.from(weekSet).sort();
            
            // Show statistics
            let statusMessage = `‚úì Added ${newRecords} new records from ${snapshotDate}`;
            if (duplicates > 0) {
                statusMessage += `\n‚ö†Ô∏è Skipped ${duplicates} duplicates`;
            }
            statusMessage += `\nüìä Total: ${snapshotData.length} records across ${availableWeeks.length} weeks`;
            
            document.getElementById('fileStatus').textContent = statusMessage;
            document.getElementById('fileStatus').style.color = duplicates > 0 ? '#fe9339' : '#2e844a';
            
            console.log(`‚úì Added ${newRecords} records, skipped ${duplicates} duplicates`);
            console.log(`Total: ${snapshotData.length} records across ${availableWeeks.length} weeks`);
            
            // Refresh dashboard with latest data
            const latestWeek = availableWeeks[availableWeeks.length - 1];
            opportunityData = snapshotData.filter(s => s.SnapshotDate === latestWeek);
            
            domainData = aggregateDomainData();
            
            const firstDomain = 'accelerators';
            currentDomain = firstDomain;
            const firstData = domainData[firstDomain];
            
            const fyProgress = calculateFYProgress();
            const todayTarget = firstData.yearTarget * fyProgress.ratio;
            const rightEdge = Math.max(firstData.actualBooking, firstData.yearTarget);
            
            targetValue = firstData.actualBooking;
            currentValue = firstData.actualBooking;
            currentTodayTarget = todayTarget;
            currentRightEdge = rightEdge;
            
            document.getElementById('domainTitle').textContent = firstData.name;
            
            drawSpeedometer();
            drawBarChart();
            drawPipelineFunnel();
            drawCumulativeChart();
            populateProgressTracking();
        }

        function loadSnapshots(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                parseSnapshots(text);
            };
            reader.readAsText(file);
        }

        function parseSnapshots(text, isMaster = false) {
            const lines = text.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.trim());
            
            // Track statistics
            let newRecords = 0;
            let duplicates = 0;
            let beforeCount = snapshotData.length;
            
            // Parse each snapshot record
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                
                const snapshot = {};
                headers.forEach((header, index) => {
                    let value = values[index] ? values[index].trim() : '';
                    
                    // Parse Amount as number
                    if (header === 'Amount') {
                        snapshot[header] = parseFloat(value) || 0;
                    } else {
                        snapshot[header] = value;
                    }
                });
                
                // Generate fingerprint for duplicate detection
                const fingerprint = getRecordFingerprint(
                    snapshot, 
                    snapshot.SnapshotDate
                );
                
                // Check if this exact record already exists
                if (existingRecords.has(fingerprint)) {
                    duplicates++;
                    continue; // Skip duplicate
                }
                
                // Add new record
                existingRecords.add(fingerprint);
                snapshotData.push(snapshot);
                newRecords++;
            }
            
            // Get unique snapshot dates (weeks)
            const weekSet = new Set(snapshotData.map(s => s.SnapshotDate));
            availableWeeks = Array.from(weekSet).sort(); // Sort chronologically
            
            // Show load statistics
            const totalAfter = snapshotData.length;
            console.log(`‚úì Loaded ${totalAfter} total snapshot records across ${availableWeeks.length} weeks`);
            console.log(`   - New records added: ${newRecords}`);
            console.log(`   - Duplicates skipped: ${duplicates}`);
            console.log('Available weeks:', availableWeeks);
            
            // Update file status with statistics
            let statusMessage = isMaster 
                ? `‚úì Loaded master file: ${availableWeeks.length} weeks, ${totalAfter} records`
                : `‚úì Loaded ${availableWeeks.length} weeks, ${totalAfter} total records`;
            
            if (duplicates > 0) {
                statusMessage += `\n‚ö†Ô∏è Skipped ${duplicates} duplicate records`;
            }
            
            if (isMaster) {
                statusMessage += `\nüì• Ready to add weekly exports`;
            }
            
            document.getElementById('fileStatus').textContent = statusMessage;
            document.getElementById('fileStatus').style.color = duplicates > 0 ? '#fe9339' : '#2e844a';
            
            // Get the LATEST snapshot as current pipeline
            const latestWeek = availableWeeks[availableWeeks.length - 1];
            opportunityData = snapshotData.filter(s => s.SnapshotDate === latestWeek);
            
            console.log(`Using latest snapshot (${latestWeek}) with ${opportunityData.length} opportunities`);
            
            // Aggregate into domain data from latest snapshot
            domainData = aggregateDomainData();
            
            // Debug: log aggregated data
            console.log('=== Aggregated Domain Data ===');
            Object.keys(domainData).forEach(key => {
                const d = domainData[key];
                console.log(`${d.name}: Booking=${d.actualBooking}, Pipeline=${d.openPipeline}, Target=${d.yearTarget}`);
            });
            
            // Update UI with first domain
            const firstDomain = 'accelerators';
            currentDomain = firstDomain;
            const firstData = domainData[firstDomain];
            
            // Calculate derived values
            const fyProgress = calculateFYProgress();
            const todayTarget = firstData.yearTarget * fyProgress.ratio;
            const rightEdge = Math.max(firstData.actualBooking, firstData.yearTarget);
            
            targetValue = firstData.actualBooking;
            currentValue = firstData.actualBooking;
            currentTodayTarget = todayTarget;
            currentYearTarget = firstData.yearTarget;
            currentRightEdge = rightEdge;
            
            document.getElementById('domainTitle').textContent = firstData.name;
            
            drawSpeedometer();
            drawBarChart();
            drawPipelineFunnel();
            drawCumulativeChart();
            populateProgressTracking();
        }

        // Update period booking info in bar chart header
        function updatePeriodBookingInfo() {
            const periodBookingElement = document.getElementById('barChartPeriodBooking');
            if (!periodBookingElement) return;

            if (domainData && Object.keys(domainData).length > 1) {
                // Calculate period dates
                const periodStartDate = new Date(calculationDate);
                periodStartDate.setDate(periodStartDate.getDate() - selectedPeriodDays);
                const startDateStr = periodStartDate.toLocaleDateString('en-US', { day: 'numeric', month: 'short' });
                const endDateStr = calculationDate.toLocaleDateString('en-US', { day: 'numeric', month: 'short' });

                // Calculate total period booking
                let totalPeriodBooking = 0;
                Object.keys(domainData).forEach(key => {
                    if (key !== 'overall' && domainData[key].bookingLastWeek) {
                        totalPeriodBooking += domainData[key].bookingLastWeek;
                    }
                });

                periodBookingElement.innerHTML = `<span style="font-weight: bold; color: #2E844A;">Period Booking: ${formatValue(totalPeriodBooking)} (${startDateStr} - ${endDateStr})</span>`;
            } else {
                periodBookingElement.textContent = '';
            }
        }

        // Draw horizontal bar chart for domains
        function drawBarChart() {
            // Update subtitle with date
            const dateStr = calculationDate.toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            });
            const subtitle = document.querySelector('#barChartSection .chart-subtitle');
            if (subtitle) {
                subtitle.textContent = `On Date ${dateStr}`;
            }

            const barCanvas = document.getElementById('domainBarChart');

            // Setup high-DPI canvas for crisp rendering
            const dpr = window.devicePixelRatio || 1;
            const rect = barCanvas.getBoundingClientRect();

            // Set display size (css pixels)
            barCanvas.style.width = rect.width + 'px';
            barCanvas.style.height = rect.height + 'px';

            // Set actual size in memory (scaled for pixel density)
            barCanvas.width = rect.width * dpr;
            barCanvas.height = rect.height * dpr;

            const barCtx = barCanvas.getContext('2d');
            barCtx.scale(dpr, dpr);

            // Clear canvas (use display dimensions)
            barCtx.clearRect(0, 0, rect.width, rect.height);
            
            // Prepare data - filter out 'overall', sort by actualBooking descending
            const domains = Object.keys(domainData)
                .filter(key => key !== 'overall')  // Remove "All Domains"
                .map(key => {
                    const booking = domainData[key].actualBooking || 0;
                    const bookingBefore = domainData[key].bookingBeforeLastWeek || 0;
                    const bookingLastWeek = domainData[key].bookingLastWeek || 0;
                    const pipeline = domainData[key].openPipeline || 0;

                    // Validate values - protect against negative or invalid numbers
                    const safeBooking = Math.max(0, isNaN(booking) ? 0 : booking);
                    const safeBookingBefore = Math.max(0, isNaN(bookingBefore) ? 0 : bookingBefore);
                    const safeBookingLastWeek = Math.max(0, isNaN(bookingLastWeek) ? 0 : bookingLastWeek);
                    const safePipeline = Math.max(0, isNaN(pipeline) ? 0 : pipeline);

                    return {
                        name: domainData[key].name,
                        booking: safeBooking,
                        bookingBefore: safeBookingBefore,
                        bookingLastWeek: safeBookingLastWeek,
                        pipeline: safePipeline,
                        yearTarget: domainData[key].yearTarget || 0,
                        key: key
                    };
                })
                .sort((a, b) => b.booking - a.booking);

            // Chart dimensions (use display dimensions, not memory dimensions)
            const chartWidth = rect.width - 220;
            const barHeight = 35;
            const barSpacing = 15;
            const leftMargin = 150;
            const topMargin = 50; // Increased to move bars down, reducing space above

            // Calculate chart height based on number of domains (for consistent spacing)
            const chartHeight = topMargin + (domains.length * (barHeight + barSpacing));

            // Find max value for scale (max of booking+pipeline across all domains)
            // Ensure minimum of 8M for consistent scale
            const dataMaxValue = Math.max(...domains.map(d => d.booking + d.pipeline));
            const maxValue = Math.max(dataMaxValue, 8000000); // Minimum 8M

            // Debug log for all domains (print once per draw, not in animation loop)
            if (!window.barChartDebugLogged) {
                console.log('=== Bar Chart Data ===');
                console.log('maxValue:', maxValue);
                domains.forEach(d => {
                    console.log(`${d.name}:`, {
                        booking: d.booking,
                        bookingBefore: d.bookingBefore,
                        bookingLastWeek: d.bookingLastWeek,
                        pipeline: d.pipeline,
                        total: d.booking + d.pipeline,
                        yearTarget: d.yearTarget
                    });
                });
                window.barChartDebugLogged = true;
                setTimeout(() => { window.barChartDebugLogged = false; }, 5000); // Reset after 5 seconds
            }

            // Draw each domain bar
            domains.forEach((domain, index) => {
                const y = topMargin + (index * (barHeight + barSpacing));
                const bookingBeforeWidth = (domain.bookingBefore / maxValue) * chartWidth;
                const bookingLastWeekWidth = (domain.bookingLastWeek / maxValue) * chartWidth;
                const pipelineWidth = (domain.pipeline / maxValue) * chartWidth;

                // Draw domain label (left)
                barCtx.fillStyle = colors.darkGray;
                barCtx.font = '13px Arial';
                barCtx.textAlign = 'right';
                barCtx.textBaseline = 'middle';
                barCtx.fillText(domain.name, leftMargin - 10, y + barHeight / 2);

                // Draw dark blue bar (booking before period)
                barCtx.fillStyle = colors.darkBlue;
                barCtx.fillRect(leftMargin, y, bookingBeforeWidth, barHeight);

                // Draw light green bar (booking during period) - starts where "before" ends
                // Apply pulsating opacity effect if there's booking in the period
                if (domain.bookingLastWeek > 0) {
                    barCtx.globalAlpha = greenBarPulseOpacity;
                }
                barCtx.fillStyle = '#2E844A'; // Salesforce success green
                barCtx.fillRect(leftMargin + bookingBeforeWidth, y, bookingLastWeekWidth, barHeight);
                barCtx.globalAlpha = 1.0; // Reset opacity

                // Draw gray bar (qualified pipeline - Value Creation/Winning Proposal/Final Commitment/Finalisation with CloseDate in current FY)
                barCtx.fillStyle = '#c9c7c5';
                barCtx.fillRect(leftMargin + bookingBeforeWidth + bookingLastWeekWidth, y, pipelineWidth, barHeight);

                // Draw vertical line for year target
                const targetX = leftMargin + (domain.yearTarget / maxValue) * chartWidth;
                barCtx.strokeStyle = '#0176d3'; // Salesforce blue
                barCtx.lineWidth = 3;
                barCtx.setLineDash([5, 3]); // Dashed line
                barCtx.beginPath();
                barCtx.moveTo(targetX, y);
                barCtx.lineTo(targetX, y + barHeight);
                barCtx.stroke();
                barCtx.setLineDash([]); // Reset to solid line

                // Draw small circle at the top of target line
                barCtx.fillStyle = '#0176d3';
                barCtx.beginPath();
                barCtx.arc(targetX, y - 3, 4, 0, 2 * Math.PI);
                barCtx.fill();

                // Draw booking value after booking bars (before + during period)
                barCtx.fillStyle = colors.darkGray;
                barCtx.font = 'bold 13px Arial';
                barCtx.textAlign = 'left';
                barCtx.fillText(
                    formatValue(domain.booking),
                    leftMargin + bookingBeforeWidth + bookingLastWeekWidth + 8,
                    y + barHeight / 2
                );
            });

            // Draw X-axis line
            barCtx.strokeStyle = '#dddbda';
            barCtx.lineWidth = 2;
            barCtx.beginPath();
            barCtx.moveTo(leftMargin, chartHeight);
            barCtx.lineTo(leftMargin + chartWidth, chartHeight);
            barCtx.stroke();

            // Draw X-axis labels at 1M intervals
            const interval = 1000000; // 1 million
            const maxMark = Math.ceil(maxValue / interval) * interval;

            for (let value = 0; value <= maxMark; value += interval) {
                // Skip if value exceeds chart bounds
                if (value > maxValue * 1.1) break;

                const x = leftMargin + (value / maxValue) * chartWidth;

                barCtx.fillStyle = colors.lightGray;
                barCtx.font = '11px Arial';
                barCtx.textAlign = 'center';
                barCtx.fillText(formatValue(value), x, chartHeight + 20);

                // Draw grid line
                barCtx.strokeStyle = '#f3f2f2';
                barCtx.lineWidth = 1;
                barCtx.beginPath();
                barCtx.moveTo(x, topMargin);
                barCtx.lineTo(x, chartHeight);
                barCtx.stroke();
            }
        }

        // Animate the green bar pulsation
        let animationFrameId = null;
        function animateGreenBarPulse() {
            // Update opacity (pulse between 0.6 and 1.0)
            greenBarPulseOpacity += greenBarPulseDirection * 0.003;

            // Reverse direction at boundaries
            if (greenBarPulseOpacity <= 0.6) {
                greenBarPulseOpacity = 0.6;
                greenBarPulseDirection = 1; // Start brightening
            } else if (greenBarPulseOpacity >= 1.0) {
                greenBarPulseOpacity = 1.0;
                greenBarPulseDirection = -1; // Start fading
            }

            // Redraw bar chart with new opacity (but without logging to avoid console spam)
            try {
                drawBarChart();
            } catch (e) {
                console.error('Error in drawBarChart animation:', e);
                stopGreenBarAnimation();
                return;
            }

            // Continue animation
            animationFrameId = requestAnimationFrame(animateGreenBarPulse);
        }

        // Start the animation when data is loaded
        let animationStarted = false;
        function startGreenBarAnimation() {
            if (!animationStarted) {
                animationStarted = true;
                animateGreenBarPulse();
            }
        }

        // Stop animation
        function stopGreenBarAnimation() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                animationStarted = false;
            }
        }

        // Draw pipeline funnel chart
        function drawPipelineFunnel() {
            if (!currentPipelineData || currentPipelineData.length === 0) {
                return;
            }

            const canvas = document.getElementById('pipelineFunnel');
            const ctx = canvas.getContext('2d');

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Calculate pipeline by stage (reconstructed at calculationDate)
            // Map Salesforce stages to funnel stages
            const stageMapping = {
                'Value Creation': 'Value Creation',
                'A Winning Proposal': 'Winning Proposal',
                'Obtaining Final Commitment': 'Final Commitment',
                'Finalisation': 'Finalisation'
            };

            const stageData = {
                'Value Creation': 0,
                'Winning Proposal': 0,
                'Final Commitment': 0,
                'Finalisation': 0
            };

            console.log('=== Pipeline Funnel DEBUG ===');
            console.log('calculationDate:', calculationDate);

            let total = 0;
            let filteredCount = 0;

            // Iterate through all opportunities and reconstruct their state at calculationDate
            currentPipelineData.forEach(opp => {
                // Reconstruct opportunity state at calculationDate
                const stateAtDate = getOpportunityStateAtDate(opp, calculationDate);

                const mappedStage = stageMapping[stateAtDate.stage];
                if (!mappedStage || !stageData.hasOwnProperty(mappedStage)) return;

                // Filter by Close Date in current fiscal year
                const closeDate = parseEuropeanDate(stateAtDate.closeDate);
                if (!closeDate) return;

                if (closeDate >= FY_START && closeDate <= FY_END) {
                    const amount = parseEuropeanAmount(stateAtDate.amount);
                    stageData[mappedStage] += amount;
                    total += amount;
                    filteredCount++;
                }
            });

            console.log('Pipeline at selected date:', stageData);
            console.log('Total pipeline:', total);

            console.log('Filtered opportunities:', filteredCount);
            
            console.log('Funnel stage data:', stageData);
            console.log('Funnel total:', total);
            
            // Update total display
            document.getElementById('funnelTotal').textContent = formatValue(total);
            
            // Funnel colors (matching Salesforce funnel)
            const colors = {
                'Value Creation': '#1B96FF',        // Bright blue (like SF screenshot)
                'Winning Proposal': '#5EAEFF',      // Light blue
                'Final Commitment': '#9050E9',      // Purple
                'Finalisation': '#B47EE5'           // Light purple
            };

            // Chart dimensions
            const width = canvas.width;
            const height = canvas.height;
            const padding = { top: 40, bottom: 80, left: 120, right: 250 };
            const chartHeight = height - padding.top - padding.bottom;
            const chartWidth = width - padding.left - padding.right;

            // Calculate funnel segments - proportional heights but proper trapezoid shape
            const stages = ['Value Creation', 'Winning Proposal', 'Final Commitment', 'Finalisation'];

            // Minimum height to fit text labels (2 lines: amount + percentage)
            const minSegmentHeight = 50;

            // Calculate proportional heights based on amounts
            let segmentHeights = stages.map(stage => {
                const amount = stageData[stage];
                const proportionalHeight = total > 0 ? (amount / total) * chartHeight : 0;
                return Math.max(proportionalHeight, minSegmentHeight);
            });

            // If total height exceeds available space due to minimums, scale down proportionally
            const totalSegmentHeight = segmentHeights.reduce((a, b) => a + b, 0);
            if (totalSegmentHeight > chartHeight) {
                const scale = chartHeight / totalSegmentHeight;
                segmentHeights = segmentHeights.map(h => h * scale);
            }

            // Calculate cumulative heights to know where each segment starts
            let cumulativeHeights = [0];
            for (let i = 0; i < segmentHeights.length; i++) {
                cumulativeHeights.push(cumulativeHeights[i] + segmentHeights[i]);
            }

            // For proper trapezoid: calculate width at any Y position using linear interpolation
            // Top width = 100%, Bottom width = 100% - (numStages * 0.08)
            const topWidthRatio = 1.0;
            const bottomWidthRatio = 1.0 - (stages.length * 0.08);

            stages.forEach((stage, index) => {
                const amount = stageData[stage];
                const percentage = total > 0 ? (amount / total) * 100 : 0;

                const segmentHeight = segmentHeights[index];
                const yTop = padding.top + cumulativeHeights[index];
                const yBottom = padding.top + cumulativeHeights[index + 1];

                // Calculate width at top and bottom of this segment using linear interpolation
                // based on position in overall trapezoid
                const topProgress = cumulativeHeights[index] / totalSegmentHeight;
                const bottomProgress = cumulativeHeights[index + 1] / totalSegmentHeight;

                const topWidth = chartWidth * (topWidthRatio - (topWidthRatio - bottomWidthRatio) * topProgress);
                const bottomWidth = chartWidth * (topWidthRatio - (topWidthRatio - bottomWidthRatio) * bottomProgress);

                const topLeft = padding.left + (chartWidth - topWidth) / 2;
                const topRight = topLeft + topWidth;
                const bottomLeft = padding.left + (chartWidth - bottomWidth) / 2;
                const bottomRight = bottomLeft + bottomWidth;

                // Draw trapezoid
                ctx.fillStyle = colors[stage];
                ctx.beginPath();
                ctx.moveTo(topLeft, yTop);
                ctx.lineTo(topRight, yTop);
                ctx.lineTo(bottomRight, yBottom);
                ctx.lineTo(bottomLeft, yBottom);
                ctx.closePath();
                ctx.fill();

                // Draw border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw text - adjust font size based on segment height
                const centerY = (yTop + yBottom) / 2;
                const availableHeight = yBottom - yTop;

                // Scale font size based on available height
                let amountFontSize = Math.min(18, Math.max(12, availableHeight * 0.3));
                let percentFontSize = Math.min(14, Math.max(10, availableHeight * 0.25));

                ctx.fillStyle = '#fff';
                ctx.font = `bold ${amountFontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const lineSpacing = availableHeight * 0.15;
                ctx.fillText(formatValue(amount), width / 2, centerY - lineSpacing);

                ctx.font = `${percentFontSize}px Arial`;
                ctx.fillText(`(${percentage.toFixed(1)}%)`, width / 2, centerY + lineSpacing);
            });
            
            // Draw legend on the right side (Salesforce style)
            const legendX = width - 200;
            const legendStartY = padding.top + 20;
            const legendLineHeight = 30;

            // Legend title
            ctx.fillStyle = '#333';
            ctx.font = 'bold 13px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Stage', legendX, legendStartY);

            // Legend items
            stages.forEach((stage, index) => {
                const itemY = legendStartY + 25 + (index * legendLineHeight);

                // Color box
                ctx.fillStyle = colors[stage];
                ctx.fillRect(legendX, itemY - 10, 15, 15);

                // Label
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(stage, legendX + 22, itemY);
            });
        }

        // Draw cumulative booking progress chart
        let cumulativeChartInstance = null;
        
        function drawCumulativeChart() {
            console.log('=== CUMULATIVE CHART CALLED ===');
            console.log('currentPipelineData length:', currentPipelineData ? currentPipelineData.length : 'null');

            if (!currentPipelineData || currentPipelineData.length === 0) {
                console.log('No pipeline data available - exiting');
                return;
            }

            console.log('=== CUMULATIVE CHART DEBUG ===');

            // Destroy previous chart instance
            if (cumulativeChartInstance) {
                cumulativeChartInstance.destroy();
            }

            const canvas = document.getElementById('cumulativeChart');
            const ctx = canvas.getContext('2d');

            // Selected date (calculationDate) - "—Å–µ–≥–æ–¥–Ω—è" –¥–ª—è —Ä–∞—Å—á–µ—Ç–æ–≤
            const today = calculationDate || new Date();

            // Previous period date - selectedPeriodDays earlier
            const previousPeriodDate = new Date(today);
            previousPeriodDate.setDate(previousPeriodDate.getDate() - selectedPeriodDays);
            // Normalize to start of day to avoid timezone issues
            previousPeriodDate.setHours(0, 0, 0, 0);

            console.log('=== CUMULATIVE CHART DATES ===');
            console.log('Current calculation date:', today.toISOString().split('T')[0]);
            console.log('Previous period date (minus ' + selectedPeriodDays + ' days):', previousPeriodDate.toISOString().split('T')[0]);

            // Fixed month labels (always 12 months)
            const monthNames = ['Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec', 'Jan', 'Feb', 'Mar'];

            // Calculate today's position on X-axis
            let todayMonthIndex = -1;
            let todayPosition = 0;

            for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
                const targetDate = new Date(FY_START);
                targetDate.setMonth(targetDate.getMonth() + monthIndex);
                const targetMonth = targetDate.getMonth();
                const targetYear = targetDate.getFullYear();

                const monthStart = new Date(targetYear, targetMonth, 1);
                const monthEnd = new Date(targetYear, targetMonth + 1, 0);

                if (monthStart <= today && today <= monthEnd) {
                    todayMonthIndex = monthIndex;
                    const dayOfMonth = today.getDate();
                    const daysInMonth = monthEnd.getDate();
                    // Position on X axis: last completed month + progress in current month
                    // For Dec (monthIndex=8), if today is 6th: position = 7 + 6/31 = 7.19
                    const lastCompletedMonth = monthIndex > 0 ? monthIndex - 1 : 0;
                    todayPosition = lastCompletedMonth + (dayOfMonth / daysInMonth);
                    console.log(`Today is in ${monthNames[monthIndex]}: day ${dayOfMonth}/${daysInMonth}, lastCompletedMonth=${lastCompletedMonth}, position = ${todayPosition.toFixed(2)}`);
                    break;
                }
            }

            // Calculate actual cumulative booking up to today
            const actualData = [];
            const qualifiedStages = ['Value Creation', 'A Winning Proposal', 'Obtaining Final Commitment', 'Finalisation'];

            // Build array of all monthly cumulative values
            const monthlyCumulative = [];
            for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
                const targetDate = new Date(FY_START);
                targetDate.setMonth(targetDate.getMonth() + monthIndex);
                const targetMonth = targetDate.getMonth();
                const targetYear = targetDate.getFullYear();
                const monthEnd = new Date(targetYear, targetMonth + 1, 0);

                // Calculate cumulative actual up to month end
                // IMPORTANT: Use state AT TODAY (not monthEnd for future months), filter by closeDate
                const calcDate = monthEnd > today ? today : monthEnd;

                const cumulativeActual = currentPipelineData
                    .filter(opp => {
                        const stateAtToday = getOpportunityStateAtDate(opp, today);
                        if (stateAtToday.stage !== 'Closed Won') return false;

                        const closeDate = parseEuropeanDate(stateAtToday.closeDate);
                        if (!closeDate) return false;

                        return closeDate >= FY_START && closeDate <= calcDate;
                    })
                    .reduce((sum, opp) => {
                        const stateAtToday = getOpportunityStateAtDate(opp, today);
                        const amount = parseEuropeanAmount(stateAtToday.amount);
                        return sum + amount;
                    }, 0);

                monthlyCumulative.push(cumulativeActual / 1000000);
                console.log(`Month ${monthIndex} (${monthNames[monthIndex]}): ${(cumulativeActual / 1000000).toFixed(2)}M EUR`);
            }

            // Calculate cumulative actual up to today
            const cumulativeToday = currentPipelineData
                .filter(opp => {
                    const stateAtDate = getOpportunityStateAtDate(opp, today);
                    if (stateAtDate.stage !== 'Closed Won') return false;

                    const closeDate = parseEuropeanDate(stateAtDate.closeDate);
                    if (!closeDate) return false;

                    return closeDate >= FY_START && closeDate <= today;
                })
                .reduce((sum, opp) => {
                    const stateAtDate = getOpportunityStateAtDate(opp, today);
                    const amount = parseEuropeanAmount(stateAtDate.amount);
                    return sum + amount;
                }, 0);

            const todayValue = cumulativeToday / 1000000;

            console.log('Today cumulative booking:', todayValue.toFixed(2), 'M EUR');

            // Build actualData: points from month 0 up to today's position
            for (let monthIndex = 0; monthIndex < todayMonthIndex; monthIndex++) {
                actualData.push({
                    x: monthIndex,
                    y: monthlyCumulative[monthIndex]
                });
            }

            // Add today's exact position
            actualData.push({
                x: todayPosition,
                y: todayValue
            });

            // Calculate projected cumulative booking from today onwards
            const projectedData = [];

            // Build array of projected cumulative for all months (actual up to today + projected after)
            const monthlyProjected = [];
            for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
                const targetDate = new Date(FY_START);
                targetDate.setMonth(targetDate.getMonth() + monthIndex);
                const targetMonth = targetDate.getMonth();
                const targetYear = targetDate.getFullYear();
                const monthEnd = new Date(targetYear, targetMonth + 1, 0);

                // Cumulative = Actual (already closed <= today) + Projected (qualified pipeline > today, closing <= monthEnd)
                const cumulativeActualToToday = currentPipelineData
                    .filter(opp => {
                        const stateAtDate = getOpportunityStateAtDate(opp, today);
                        if (stateAtDate.stage !== 'Closed Won') return false;

                        const closeDate = parseEuropeanDate(stateAtDate.closeDate);
                        if (!closeDate) return false;

                        return closeDate >= FY_START && closeDate <= today;
                    })
                    .reduce((sum, opp) => {
                        const stateAtDate = getOpportunityStateAtDate(opp, today);
                        const amount = parseEuropeanAmount(stateAtDate.amount);
                        return sum + amount;
                    }, 0);

                const cumulativeProjectedUpToMonth = currentPipelineData
                    .filter(opp => {
                        const stateAtDate = getOpportunityStateAtDate(opp, today);

                        if (stateAtDate.stage === 'Closed Lost' || stateAtDate.stage === 'Closed Disengaged') return false;

                        if (stateAtDate.stage === 'Closed Won') {
                            const closeDate = parseEuropeanDate(stateAtDate.closeDate);
                            if (closeDate && closeDate <= today) return false;
                        }

                        if (!qualifiedStages.includes(stateAtDate.stage)) return false;

                        const closeDate = parseEuropeanDate(stateAtDate.closeDate);
                        if (!closeDate) return false;

                        return closeDate > today && closeDate <= monthEnd;
                    })
                    .reduce((sum, opp) => {
                        const stateAtDate = getOpportunityStateAtDate(opp, today);
                        const amount = parseEuropeanAmount(stateAtDate.amount);
                        return sum + amount;
                    }, 0);

                monthlyProjected.push((cumulativeActualToToday + cumulativeProjectedUpToMonth) / 1000000);
            }

            // Start projected line from today's position
            projectedData.push({
                x: todayPosition,
                y: todayValue
            });

            // Add projected points for remaining months
            for (let monthIndex = todayMonthIndex; monthIndex < 12; monthIndex++) {
                projectedData.push({
                    x: monthIndex,
                    y: monthlyProjected[monthIndex]
                });
            }

            // Calculate orange line (Previous Period Plan) - snapshot at previousPeriodDate
            const previousProjectedData = [];

            // Calculate previousPeriodDate position
            let previousMonthIndex = -1;
            let previousPosition = 0;

            console.log('Searching for previousPeriodDate:', previousPeriodDate.toISOString().split('T')[0]);
            console.log('FY_START:', FY_START.toISOString().split('T')[0], 'FY_END:', FY_END.toISOString().split('T')[0]);
            console.log('previousPeriodDate < FY_START:', previousPeriodDate < FY_START);
            console.log('previousPeriodDate > FY_END:', previousPeriodDate > FY_END);

            // Check if previousPeriodDate is before FY start or after FY end
            if (previousPeriodDate < FY_START) {
                previousMonthIndex = 0;
                previousPosition = 0;
                console.log('Previous period date is before FY start, setting to beginning of year');
            } else if (previousPeriodDate > FY_END) {
                // If previousPeriodDate is after FY end, treat it as end of year
                previousMonthIndex = 11;
                previousPosition = 11;
                console.log('Previous period date is after FY end, setting to end of year');
            } else {
                console.log('Searching within FY months...');
                for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
                    const targetDate = new Date(FY_START);
                    targetDate.setMonth(targetDate.getMonth() + monthIndex);
                    const targetMonth = targetDate.getMonth();
                    const targetYear = targetDate.getFullYear();

                    const monthStart = new Date(targetYear, targetMonth, 1);
                    const monthEnd = new Date(targetYear, targetMonth + 1, 0);

                    if (monthStart <= previousPeriodDate && previousPeriodDate <= monthEnd) {
                        previousMonthIndex = monthIndex;
                        const dayOfMonth = previousPeriodDate.getDate();
                        const daysInMonth = monthEnd.getDate();
                        const lastCompletedMonth = monthIndex > 0 ? monthIndex - 1 : 0;
                        previousPosition = lastCompletedMonth + (dayOfMonth / daysInMonth);
                        console.log(`FOUND: Previous period date is in ${monthNames[monthIndex]}: day ${dayOfMonth}/${daysInMonth}, position = ${previousPosition.toFixed(2)}`);
                        break;
                    }
                }
                if (previousMonthIndex === -1) {
                    console.log('ERROR: Could not find previousPeriodDate month in FY!');
                    console.log('This suggests previousPeriodDate timezone issue or date parsing problem');
                }
            }

            // Calculate actual booking at previousPeriodDate
            const previousActual = currentPipelineData
                .filter(opp => {
                    const stateAtPrevious = getOpportunityStateAtDate(opp, previousPeriodDate);
                    if (stateAtPrevious.stage !== 'Closed Won') return false;

                    const closeDate = parseEuropeanDate(stateAtPrevious.closeDate);
                    if (!closeDate) return false;

                    return closeDate >= FY_START && closeDate <= previousPeriodDate;
                })
                .reduce((sum, opp) => {
                    const stateAtPrevious = getOpportunityStateAtDate(opp, previousPeriodDate);
                    const amount = parseEuropeanAmount(stateAtPrevious.amount);
                    return sum + amount;
                }, 0) / 1000000;

            console.log('Previous period actual booking:', previousActual.toFixed(2), 'M EUR');

            // Build projected line from previousPeriodDate
            const monthlyPreviousProjected = [];
            console.log('Building orange line. previousMonthIndex:', previousMonthIndex, 'previousPosition:', previousPosition.toFixed(2));
            for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
                const targetDate = new Date(FY_START);
                targetDate.setMonth(targetDate.getMonth() + monthIndex);
                const targetMonth = targetDate.getMonth();
                const targetYear = targetDate.getFullYear();
                const monthEnd = new Date(targetYear, targetMonth + 1, 0);

                let cumulativeValue;

                // For months before or including previousPeriodDate month - use actual data at that month end
                if (monthIndex < previousMonthIndex) {
                    // Use actual closed won up to end of this month
                    // Important: we check state at monthEnd, not at previousPeriodDate
                    cumulativeValue = currentPipelineData
                        .filter(opp => {
                            const stateAtMonthEnd = getOpportunityStateAtDate(opp, monthEnd);
                            if (stateAtMonthEnd.stage !== 'Closed Won') return false;

                            const closeDate = parseEuropeanDate(stateAtMonthEnd.closeDate);
                            if (!closeDate) return false;

                            return closeDate >= FY_START && closeDate <= monthEnd;
                        })
                        .reduce((sum, opp) => {
                            const stateAtMonthEnd = getOpportunityStateAtDate(opp, monthEnd);
                            const amount = parseEuropeanAmount(stateAtMonthEnd.amount);
                            return sum + amount;
                        }, 0);
                } else {
                    // For months from previousPeriodDate onwards - use actual + projected
                    // Actual up to previousPeriodDate
                    const actualToPrevious = currentPipelineData
                        .filter(opp => {
                            const stateAtPrevious = getOpportunityStateAtDate(opp, previousPeriodDate);
                            if (stateAtPrevious.stage !== 'Closed Won') return false;

                            const closeDate = parseEuropeanDate(stateAtPrevious.closeDate);
                            if (!closeDate) return false;

                            return closeDate >= FY_START && closeDate <= previousPeriodDate;
                        })
                        .reduce((sum, opp) => {
                            const stateAtPrevious = getOpportunityStateAtDate(opp, previousPeriodDate);
                            const amount = parseEuropeanAmount(stateAtPrevious.amount);
                            return sum + amount;
                        }, 0);

                    // Projected from previousPeriodDate to month end
                    const projectedUpToMonth = currentPipelineData
                        .filter(opp => {
                            const stateAtPrevious = getOpportunityStateAtDate(opp, previousPeriodDate);

                            if (stateAtPrevious.stage === 'Closed Lost' || stateAtPrevious.stage === 'Closed Disengaged') return false;

                            if (stateAtPrevious.stage === 'Closed Won') {
                                const closeDate = parseEuropeanDate(stateAtPrevious.closeDate);
                                if (closeDate && closeDate <= previousPeriodDate) return false;
                            }

                            if (!qualifiedStages.includes(stateAtPrevious.stage)) return false;

                            const closeDate = parseEuropeanDate(stateAtPrevious.closeDate);
                            if (!closeDate) return false;

                            return closeDate > previousPeriodDate && closeDate <= monthEnd;
                        })
                        .reduce((sum, opp) => {
                            const stateAtPrevious = getOpportunityStateAtDate(opp, previousPeriodDate);
                            const amount = parseEuropeanAmount(stateAtPrevious.amount);
                            return sum + amount;
                        }, 0);

                    cumulativeValue = actualToPrevious + projectedUpToMonth;
                }

                monthlyPreviousProjected.push(cumulativeValue / 1000000);
            }

            console.log('monthlyPreviousProjected values:', monthlyPreviousProjected.map((v, i) => `Month ${i}: ${v.toFixed(2)}M`).join(', '));

            // Add points from start of year (0) to previousPosition with accumulated values
            if (previousMonthIndex > 0) {
                // Add points for completed months before previousPosition
                for (let monthIndex = 0; monthIndex < previousMonthIndex; monthIndex++) {
                    previousProjectedData.push({
                        x: monthIndex,
                        y: monthlyPreviousProjected[monthIndex]
                    });
                }
            }

            // Add the point at previousPosition
            previousProjectedData.push({
                x: previousPosition,
                y: previousActual
            });

            // Add projected points for remaining months from previousMonthIndex
            for (let monthIndex = previousMonthIndex; monthIndex < 12; monthIndex++) {
                previousProjectedData.push({
                    x: monthIndex,
                    y: monthlyPreviousProjected[monthIndex]
                });
            }

            console.log('Previous projected data points:', previousProjectedData.length);
            console.log('Previous projected data:', previousProjectedData);

            // Calculate target line (linear)
            const totalTarget = 18100000;
            const targetData = [];
            for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
                targetData.push({
                    x: monthIndex,
                    y: (totalTarget * (monthIndex + 1) / 12) / 1000000
                });
            }

            // Create pointRadius arrays - set 0 at connection point
            const actualPointRadius = actualData.map((_, i) => i === actualData.length - 1 ? 0 : 5);
            const projectedPointRadius = projectedData.map((_, i) => i === 0 ? 0 : 5);
            const previousPointRadius = previousProjectedData.map((_, i) => i === 0 ? 0 : 4);

            console.log('Actual data:', actualData);
            console.log('Projected data:', projectedData);

            // Create chart
            cumulativeChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: monthNames,
                    datasets: [
                        {
                            label: 'Actual Closed Won',
                            data: actualData,
                            borderColor: '#4472C4',
                            backgroundColor: '#4472C4',
                            borderWidth: 3,
                            pointRadius: actualPointRadius,
                            pointHoverRadius: 7,
                            tension: 0,
                            spanGaps: false
                        },
                        {
                            label: 'Projected Pipeline',
                            data: projectedData,
                            borderColor: '#E74C3C',
                            backgroundColor: '#E74C3C',
                            borderWidth: 3,
                            borderDash: [10, 5],
                            pointRadius: projectedPointRadius,
                            pointHoverRadius: 7,
                            tension: 0,
                            spanGaps: false
                        },
                        {
                            label: 'Previous Period Plan',
                            data: previousProjectedData,
                            borderColor: '#FF8C00',
                            backgroundColor: '#FF8C00',
                            borderWidth: 2,
                            borderDash: [5, 3],
                            pointRadius: previousPointRadius,
                            pointHoverRadius: 6,
                            tension: 0,
                            spanGaps: false
                        },
                        {
                            label: 'Target',
                            data: targetData,
                            borderColor: '#000000',
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            pointRadius: 0,
                            tension: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    layout: {
                        padding: {
                            top: 20,
                            bottom: 20,
                            left: 10,
                            right: 10
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            mode: 'x',
                            intersect: false,
                            callbacks: {
                                title: function(context) {
                                    // Show month name as title
                                    const monthIndex = Math.round(context[0].parsed.x);
                                    return monthNames[monthIndex] || '';
                                },
                                label: function(context) {
                                    const value = context.parsed.y;
                                    if (value === null || value === undefined) {
                                        return null;
                                    }
                                    return context.dataset.label + ': ‚Ç¨' + value.toFixed(2) + 'M';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return '‚Ç¨' + value + 'M';
                                }
                            },
                            title: {
                                display: true,
                                text: 'Cumulative Amount (‚Ç¨M)'
                            }
                        },
                        x: {
                            type: 'linear',
                            min: 0,
                            max: 11,
                            ticks: {
                                stepSize: 1,
                                callback: function(value) {
                                    return monthNames[Math.round(value)] || '';
                                }
                            },
                            title: {
                                display: true,
                                text: 'Months of FY25'
                            }
                        }
                    }
                }
            });
        }

        // Populate progress tracking tables using Field History
        function populateProgressTracking() {
            console.log('=== populateProgressTracking called ===');
            console.log('fieldHistoryData:', fieldHistoryData ? fieldHistoryData.length : 'null');
            console.log('currentPipelineData:', currentPipelineData ? currentPipelineData.length : 'null');

            if (!fieldHistoryData || fieldHistoryData.length === 0) {
                console.log('No field history data - showing placeholder');
                // Update all table titles with "No field history data"
                document.getElementById('closedTitle').textContent = 'CLOSED THIS PERIOD [No data]';
                document.getElementById('progressedTitle').textContent = 'PROGRESSED [No data]';
                document.getElementById('slippedTitle').textContent = 'SLIPPED [No data]';
                document.getElementById('newDealsTitle').textContent = 'NEW OPPORTUNITIES [No data]';
                document.getElementById('lostTitle').textContent = 'LOST & DISENGAGED [No data]';
                const noDataMsg = '<tr><td colspan="5" style="text-align: center; color: #706e6b;">No field history data loaded</td></tr>';
                document.getElementById('closedProgressBody').innerHTML = noDataMsg;
                document.getElementById('progressedBody').innerHTML = noDataMsg;
                document.getElementById('slippedBody').innerHTML = noDataMsg;
                document.getElementById('newDealsBody').innerHTML = noDataMsg;
                document.getElementById('lostBody').innerHTML = noDataMsg;

                // Still populate new tables if currentPipelineData is available
                if (currentPipelineData && currentPipelineData.length > 0) {
                    console.log('Calling populateClosingTables()...');
                    populateClosingTables();
                } else {
                    console.log('No currentPipelineData - skipping closing tables');
                }
                return;
            }

            // Also populate closing tables if currentPipelineData is available
            if (currentPipelineData && currentPipelineData.length > 0) {
                console.log('Calling populateClosingTables()...');
                populateClosingTables();
            }
            
            // Get date range from selected period
            const periods = calculatePeriodDates();
            const periodLabel = getPeriodLabel();

            const formatDateRange = (start, end) => {
                const opts = { day: '2-digit', month: '2-digit' };
                return `${start.toLocaleDateString('en-GB', opts)} - ${end.toLocaleDateString('en-GB', opts)}`;
            };

            // Update all table titles with period dates
            const startDate = periods.start.toLocaleDateString('en-GB', { day: '2-digit', month: '2-digit' });
            const endDate = periods.end.toLocaleDateString('en-GB', { day: '2-digit', month: '2-digit' });
            const dateRange = `[${startDate} - ${endDate}]`;

            document.getElementById('closedTitle').textContent = `CLOSED THIS PERIOD ${dateRange}`;
            document.getElementById('progressedTitle').textContent = `PROGRESSED ${dateRange}`;
            document.getElementById('slippedTitle').textContent = `SLIPPED ${dateRange}`;
            document.getElementById('newDealsTitle').textContent = `NEW OPPORTUNITIES ${dateRange}`;
            document.getElementById('lostTitle').textContent = `LOST & DISENGAGED ${dateRange}`;
            
            // Create opportunity lookup from current pipeline
            const oppLookup = {};
            currentPipelineData.forEach((opp, idx) => {
                const oppId = opp['Opportunity ID'];
                oppLookup[oppId] = opp;

                // Debug first few
                if (idx < 3) {
                    console.log(`Lookup [${idx}]: ID="${oppId}", Name="${opp['Opportunity Name']}", Amount="${opp['Net Amount']}"`);
                }
            });

            console.log('=== VERSION 2.0 - NEW LOGIC ===');
            console.log(`‚úì Created lookup for ${Object.keys(oppLookup).length} opportunities`);
            console.log(`First 3 lookup keys:`, Object.keys(oppLookup).slice(0, 3));
            
            // Analyze field history for last week
            const closed = [];
            const progressed = [];
            const slipped = [];
            const newDeals = [];
            const lostDeals = [];
            
            const processedOpps = new Set(); // Track to avoid duplicates
            
            fieldHistoryData.forEach((record, idx) => {
                const rawEditDate = record['Edit Date'];
                const editDate = parseEuropeanDate(rawEditDate);
                
                // Debug first few records
                if (idx < 5) {
                    console.log(`\n--- Field History ${idx + 1} ---`);
                    console.log('Raw Edit Date:', rawEditDate);
                    console.log('Parsed Edit Date:', editDate);
                    console.log('Field:', record['Field / Event']);
                    console.log('Opp ID:', record['Opportunity ID']);
                }
                
                if (!editDate) return;

                const recordDate = new Date(editDate);
                if (recordDate < periods.start || recordDate > periods.end) return; // Not in selected period
                
                const oppId = record['Opportunity ID'];
                const field = record['Field / Event'];
                const oldValue = record['Old Value'];
                const newValue = record['New Value'];

                const opp = oppLookup[oppId];

                // SKIP if opportunity not found in current pipeline
                if (!opp) return;

                // Get all data from current pipeline
                const oppName = opp['Opportunity Name'];
                const owner = opp['Opportunity Owner'];
                const domain = opp['Opportunity Domain'];
                const amount = parseEuropeanAmount(opp['Net Amount']);
                const closeDate = opp['Close Date'];
                const stage = opp['Stage'];
                const postMortem = opp['Post Mortem'] || '';

                // CLOSED DEALS - Stage changed to "Closed Won"
                if (field === 'Stage' && newValue === 'Closed Won' && !processedOpps.has(`closed-${oppId}`)) {
                    closed.push({
                        oppId: oppId,
                        name: oppName,
                        owner: owner,
                        domain: domain,
                        amount: amount,
                        closeDate: closeDate,
                        oldStage: oldValue,
                        date: editDate
                    });
                    processedOpps.add(`closed-${oppId}`);
                }

                // PROGRESSED - Stage changed (but not to Closed Won/Lost/Disengaged)
                // AND not already closed in this period
                // ONLY show if moved INTO or OUT OF qualified pipeline
                if (field === 'Stage' &&
                    newValue !== 'Closed Won' &&
                    newValue !== 'Closed Lost' &&
                    newValue !== 'Closed Disengaged' &&
                    !processedOpps.has(`progressed-${oppId}`) &&
                    !processedOpps.has(`closed-${oppId}`)) {

                    // Qualified stages
                    const qualifiedStages = ['Value Creation', 'A Winning Proposal', 'Obtaining Final Commitment', 'Finalisation'];
                    const wasQualified = qualifiedStages.includes(oldValue);
                    const isQualified = qualifiedStages.includes(newValue);

                    // Show if either old or new stage is qualified (but not both unqualified)
                    // This includes: entering qualified, exiting qualified, or moving within qualified
                    // Excludes: moving within unqualified stages (Identification <-> Qualification)
                    if (wasQualified || isQualified) {
                        progressed.push({
                            oppId: oppId,
                            name: oppName,
                            owner: owner,
                            domain: domain,
                            amount: amount,
                            closeDate: closeDate,
                            oldStage: oldValue,
                            newStage: newValue,
                            date: editDate
                        });
                        processedOpps.add(`progressed-${oppId}`);
                    }
                }

                // SLIPPED - Close Date moved to the right (later)
                if (field === 'Close Date' && !processedOpps.has(`slipped-${oppId}`)) {
                    const oldDate = parseEuropeanDate(oldValue);
                    const newDate = parseEuropeanDate(newValue);

                    if (oldDate && newDate && new Date(newDate) > new Date(oldDate)) {
                        // Only include QUALIFIED open opportunities (same as Closing tables logic)
                        const qualifiedStages = ['Value Creation', 'A Winning Proposal', 'Obtaining Final Commitment', 'Finalisation'];
                        
                        // Must be in qualified stages AND not closed
                        const isQualified = qualifiedStages.includes(stage);
                        const isClosed = (stage === 'Closed Won' || stage === 'Closed Lost' || stage === 'Closed Disengaged');
                        
                        if (isQualified && !isClosed) {
                            slipped.push({
                                oppId: oppId,
                                name: oppName,
                                owner: owner,
                                domain: domain,
                                amount: amount,
                                oldDate: oldValue,
                                newDate: newValue,
                                stage: stage,
                                date: editDate
                            });
                            processedOpps.add(`slipped-${oppId}`);
                        }
                    }
                }

                // NEW DEALS - Created in last week
                if (field === 'Created.' && !processedOpps.has(`new-${oppId}`)) {
                    newDeals.push({
                        oppId: oppId,
                        name: oppName,
                        owner: owner,
                        domain: domain,
                        amount: amount,
                        closeDate: closeDate,
                        stage: stage,
                        date: editDate
                    });
                    processedOpps.add(`new-${oppId}`);
                }

                // LOST & DISENGAGED - Stage changed to Closed Lost or Closed Disengaged
                // Only track if the deal was in qualified pipeline
                if (field === 'Stage' &&
                    (newValue === 'Closed Lost' || newValue === 'Closed Disengaged') &&
                    !processedOpps.has(`lost-${oppId}`)) {

                    // Check if oldStage was in qualified pipeline
                    const qualifiedStages = ['Value Creation', 'A Winning Proposal', 'Obtaining Final Commitment', 'Finalisation'];
                    const wasQualified = qualifiedStages.includes(oldValue);

                    if (wasQualified) {
                        lostDeals.push({
                            oppId: oppId,
                            name: oppName,
                            owner: owner,
                            domain: domain,
                            amount: amount,
                            oldStage: oldValue,
                            newStage: newValue,
                            date: editDate,
                            postMortem: postMortem
                        });
                        processedOpps.add(`lost-${oppId}`);
                    }
                }
            });
            
            console.log('Progress Tracking Results:');
            console.log('  Closed:', closed.length);
            console.log('  Progressed:', progressed.length);
            console.log('  Slipped:', slipped.length);
            console.log('  New Deals:', newDeals.length);
            console.log('  Lost:', lostDeals.length);

            // Sort Closed Won by Owner
            closed.sort((a, b) => {
                const ownerA = (a.owner || '').toLowerCase();
                const ownerB = (b.owner || '').toLowerCase();
                return ownerA.localeCompare(ownerB);
            });

            // Populate progress tracking tables
            populateClosedTable(closed);
            populateProgressedTable(progressed);
            populateSlippedTable(slipped);
            populateNewDealsTable(newDeals);
            populateLostTable(lostDeals);
        }

        // Separate function to populate closing tables (uses currentPipelineData)
        function populateClosingTables() {
            console.log('=== populateClosingTables called ===');
            console.log('currentPipelineData:', currentPipelineData ? currentPipelineData.length : 'null');

            if (!currentPipelineData || currentPipelineData.length === 0) {
                console.log('No currentPipelineData - exiting');
                return;
            }

            const referenceDate = new Date(calculationDate);
            console.log('Reference Date (calculationDate):', referenceDate);
            const qualifiedStages = ['Value Creation', 'A Winning Proposal', 'Obtaining Final Commitment', 'Finalisation'];

            // Get deals closing this week (next 7 days from reference date)
            const nextWeekEnd = new Date(referenceDate);
            nextWeekEnd.setDate(referenceDate.getDate() + 7);

            const closingThisWeek = [];

            currentPipelineData.forEach(opp => {
                // Get historical state at reference date
                const historicalState = getOpportunityStateAtDate(opp, referenceDate);
                const stage = historicalState.stage;

                // Only qualified pipeline (not Closed Won/Lost/Disengaged, not Identification/Qualification)
                if (stage === 'Closed Won' || stage === 'Closed Lost' || stage === 'Closed Disengaged') return;
                if (!qualifiedStages.includes(stage)) return;

                const closeDateStr = historicalState.closeDate;
                if (!closeDateStr) return;

                const closeDate = parseEuropeanDate(closeDateStr);
                if (!closeDate) return;

                // Check if close date is in the next 7 days from reference date
                if (closeDate > referenceDate && closeDate <= nextWeekEnd) {
                    closingThisWeek.push({
                        oppId: historicalState.oppId,
                        name: historicalState.name,
                        owner: historicalState.owner,
                        domain: historicalState.domain,
                        amount: parseEuropeanAmount(historicalState.amount),
                        closeDate: closeDateStr,
                        stage: stage
                    });
                }
            });

            // Sort by close date
            closingThisWeek.sort((a, b) => {
                const dateA = parseEuropeanDate(a.closeDate);
                const dateB = parseEuropeanDate(b.closeDate);
                return dateA - dateB;
            });

            // Get deals closing this month (based on reference date)
            const currentMonth = referenceDate.getMonth();
            const currentYear = referenceDate.getFullYear();
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
            const currentMonthName = monthNames[currentMonth];

            const closingThisMonth = [];

            currentPipelineData.forEach(opp => {
                // Get historical state at reference date
                const historicalState = getOpportunityStateAtDate(opp, referenceDate);
                const stage = historicalState.stage;

                // Only qualified pipeline (not Closed Won/Lost/Disengaged, not Identification/Qualification)
                if (stage === 'Closed Won' || stage === 'Closed Lost' || stage === 'Closed Disengaged') return;
                if (!qualifiedStages.includes(stage)) return;

                const closeDateStr = historicalState.closeDate;
                if (!closeDateStr) return;

                const closeDate = parseEuropeanDate(closeDateStr);
                if (!closeDate) return;

                // Check if close date is in current month
                if (closeDate.getMonth() === currentMonth && closeDate.getFullYear() === currentYear) {
                    closingThisMonth.push({
                        oppId: historicalState.oppId,
                        name: historicalState.name,
                        owner: historicalState.owner,
                        domain: historicalState.domain,
                        amount: parseEuropeanAmount(historicalState.amount),
                        closeDate: closeDateStr,
                        stage: stage
                    });
                }
            });

            // Sort by owner, then by close date
            closingThisMonth.sort((a, b) => {
                const ownerCompare = (a.owner || '').localeCompare(b.owner || '');
                if (ownerCompare !== 0) return ownerCompare;
                const dateA = parseEuropeanDate(a.closeDate);
                const dateB = parseEuropeanDate(b.closeDate);
                return dateA - dateB;
            });

            console.log('Closing This Week:', closingThisWeek.length, 'deals');
            console.log('Closing This Month:', closingThisMonth.length, 'deals');

            // Update month name in UI
            try {
                console.log('Updating month name in UI...');
                const titleEl = document.getElementById('closingThisMonthTitle');
                const headerEl = document.getElementById('closingThisMonthHeader');
                console.log('titleEl:', titleEl ? 'found' : 'NOT FOUND');
                console.log('headerEl:', headerEl ? 'found' : 'NOT FOUND');

                if (titleEl) titleEl.textContent = `Closing in ${currentMonthName}`;
                if (headerEl) headerEl.textContent = `CLOSING IN ${currentMonthName.toUpperCase()}`;
            } catch (err) {
                console.error('Error updating month name:', err);
            }

            // Populate tables
            try {
                console.log('Calling populateClosingThisWeekTable...');
                populateClosingThisWeekTable(closingThisWeek);
                console.log('populateClosingThisWeekTable completed');
            } catch (err) {
                console.error('Error in populateClosingThisWeekTable:', err);
            }

            try {
                console.log('Calling populateClosingThisMonthTable...');
                populateClosingThisMonthTable(closingThisMonth);
                console.log('populateClosingThisMonthTable completed');
            } catch (err) {
                console.error('Error in populateClosingThisMonthTable:', err);
            }

            console.log('=== populateClosingTables completed ===');
        }

        function populateClosedTable(deals) {
            const tbody = document.getElementById('closedProgressBody');
            const summary = document.getElementById('closedSummary');

            if (deals.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #706e6b;">No deals closed this week</td></tr>';
                if (summary) summary.textContent = '(0 deals, ‚Ç¨0)';
                return;
            }

            // Calculate total
            const totalAmount = deals.reduce((sum, deal) => sum + (deal.amount || 0), 0);
            if (summary) {
                summary.textContent = `(${deals.length} deals, ${formatValue(totalAmount)})`;
            }

            let html = '';
            deals.forEach((deal, index) => {
                const sfLink = deal.oppId ? `https://cosylab.lightning.force.com/lightning/r/Opportunity/${deal.oppId}/view` : '#';
                const oppName = deal.oppId ? `<a href="${sfLink}" target="_blank" style="color: #0176d3; text-decoration: none;">${deal.name || 'N/A'}</a>` : (deal.name || 'N/A');

                html += `
                    <tr>
                        <td style="text-align: center; color: #706e6b;">${index + 1}</td>
                        <td>${oppName}</td>
                        <td>${deal.domain || '-'}</td>
                        <td>${deal.owner || 'N/A'}</td>
                        <td style="font-weight: 600;">${deal.amount ? formatValue(deal.amount) : '‚Ç¨0'}</td>
                        <td>${deal.closeDate || 'N/A'}</td>
                    </tr>
                `;
            });

            // Add total row
            html += `
                <tr style="border-top: 2px solid #706e6b; background-color: #f3f2f2;">
                    <td></td>
                    <td colspan="3" style="text-align: right; font-weight: 700;">TOTAL:</td>
                    <td style="font-weight: 700;">${formatValue(totalAmount)}</td>
                    <td></td>
                </tr>
            `;

            tbody.innerHTML = html;
        }
        
        function populateProgressedTable(deals) {
            const tbody = document.getElementById('progressedBody');
            const summary = document.getElementById('progressedSummary');

            // Qualified stages
            const qualifiedStages = ['Value Creation', 'A Winning Proposal', 'Obtaining Final Commitment', 'Finalisation'];

            const summaryCenter = document.getElementById('progressedSummaryCenter');

            if (deals.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; color: #706e6b;">No stage progression this week</td></tr>';
                if (summaryCenter) summaryCenter.innerHTML = '<span style="color: #2e844a; font-size: 24px; font-weight: 900;">‚Üí</span> <span style="font-weight: bold;">‚Ç¨0</span>  |  <span style="color: #c23934; font-size: 24px; font-weight: 900;">‚Üê</span> <span style="font-weight: bold;">‚Ç¨0</span>';
                if (summary) summary.textContent = '(0 deals)';
                return;
            }

            // Calculate sums
            let movedToQualified = 0;
            let movedFromQualified = 0;

            deals.forEach(deal => {
                const wasQualified = qualifiedStages.includes(deal.oldStage);
                const isQualified = qualifiedStages.includes(deal.newStage);
                const amount = deal.amount || 0;

                if (!wasQualified && isQualified) {
                    // Moved INTO qualified
                    movedToQualified += amount;
                } else if (wasQualified && !isQualified) {
                    // Moved OUT OF qualified
                    movedFromQualified += amount;
                }
            });

            // Update center with arrows and amounts
            if (summaryCenter) {
                summaryCenter.innerHTML = `<span style="color: #2e844a; font-size: 24px; font-weight: 900;">‚Üí</span> <span style="font-weight: bold;">${formatValue(movedToQualified)}</span>  |  <span style="color: #c23934; font-size: 24px; font-weight: 900;">‚Üê</span> <span style="font-weight: bold;">${formatValue(movedFromQualified)}</span>`;
            }

            // Update right side with deal count
            if (summary) {
                summary.textContent = `(${deals.length} deals)`;
            }

            // Stage order for progression detection
            const stageOrder = [
                'Opportunity Identification',
                'Opportunity Qualification',
                'Value Creation',
                'A Winning Proposal',
                'Obtaining Final Commitment',
                'Finalisation',
                'Closed Won'
            ];

            // Sort deals by close date ascending
            deals.sort((a, b) => {
                const dateA = parseEuropeanDate(a.closeDate);
                const dateB = parseEuropeanDate(b.closeDate);
                if (dateA && dateB) {
                    return dateA - dateB;
                }
                // Put items without valid dates at the end
                if (!dateA && dateB) return 1;
                if (dateA && !dateB) return -1;
                return 0;
            });

            let html = '';
            deals.forEach((deal, index) => {
                const sfLink = deal.oppId ? `https://cosylab.lightning.force.com/lightning/r/Opportunity/${deal.oppId}/view` : '#';
                const oppName = deal.oppId ? `<a href="${sfLink}" target="_blank" style="color: #0176d3; text-decoration: none;">${deal.name || 'N/A'}</a>` : (deal.name || 'N/A');

                // Determine if progress or regress
                const oldIndex = stageOrder.indexOf(deal.oldStage);
                const newIndex = stageOrder.indexOf(deal.newStage);
                let indicator = '';

                if (oldIndex !== -1 && newIndex !== -1) {
                    if (newIndex > oldIndex) {
                        indicator = '<span style="color: #2e7d32; font-weight: bold; font-size: 1.2em;">‚ñ≤</span> ';
                    } else if (newIndex < oldIndex) {
                        indicator = '<span style="color: #d32f2f; font-weight: bold; font-size: 1.2em;">‚ñº</span> ';
                    }
                }

                html += `
                    <tr>
                        <td style="text-align: center; color: #706e6b;">${index + 1}</td>
                        <td>${oppName}</td>
                        <td>${deal.domain || '-'}</td>
                        <td>${deal.owner || 'N/A'}</td>
                        <td style="font-weight: 600;">${deal.amount ? formatValue(deal.amount) : '‚Ç¨0'}</td>
                        <td style="color: #706e6b;">${deal.closeDate || 'N/A'}</td>
                        <td>${indicator}${deal.oldStage || 'N/A'} ‚Üí ${deal.newStage || 'N/A'}</td>
                    </tr>
                `;
            });

            // Add total row
            const totalAmount = deals.reduce((sum, deal) => sum + (deal.amount || 0), 0);
            html += `
                <tr style="border-top: 2px solid #706e6b; background-color: #f3f2f2;">
                    <td></td>
                    <td colspan="3" style="text-align: right; font-weight: 700;">TOTAL:</td>
                    <td style="font-weight: 700;">${formatValue(totalAmount)}</td>
                    <td></td>
                    <td></td>
                </tr>
            `;

            tbody.innerHTML = html;
        }

        function populateSlippedTable(deals) {
            const tbody = document.getElementById('slippedBody');
            const summary = document.getElementById('slippedSummary');
            const summaryCenter = document.getElementById('slippedSummaryCenter');
            
            // DEBUG: Log stage distribution
            console.log('=== SLIPPED TABLE DEBUG ===');
            console.log(`Total slipped deals received: ${deals.length}`);
            if (deals.length > 0) {
                const stageCount = {};
                deals.forEach(deal => {
                    const stage = deal.stage || 'Unknown';
                    stageCount[stage] = (stageCount[stage] || 0) + 1;
                });
                console.log('Stages in slipped deals:', stageCount);
            }
            console.log('===========================');

            if (deals.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #706e6b;">No slipped deals this week</td></tr>';
                if (summaryCenter) summaryCenter.innerHTML = '<span style="color: #c23934; font-size: 16px;">üî¥</span> <span style="font-size: 12px; color: #706e6b;">Slipped out of FY:</span> <span style="color: #ea8c55; font-size: 24px; font-weight: 900;">‚á¢</span> <span style="font-weight: bold;">‚Ç¨0</span>';
                if (summary) summary.textContent = '(0 deals, 0 out of FY)';
                return;
            }

            // Calculate sum and count of deals slipped OUT OF current fiscal year
            let slippedOutOfFY = 0;
            let slippedOutOfFYCount = 0;

            deals.forEach(deal => {
                const oldDate = parseEuropeanDate(deal.oldDate);
                const newDate = parseEuropeanDate(deal.newDate);

                // Check if slipped out of FY (was in FY, now out of FY)
                const wasInFY = oldDate && oldDate >= FY_START && oldDate <= FY_END;
                const isInFY = newDate && newDate >= FY_START && newDate <= FY_END;

                if (wasInFY && !isInFY) {
                    slippedOutOfFY += (deal.amount || 0);
                    slippedOutOfFYCount++;
                }
            });

            // Update center with red circle, label, arrow and amount
            if (summaryCenter) {
                summaryCenter.innerHTML = `<span style="color: #c23934; font-size: 16px;">üî¥</span> <span style="font-size: 12px; color: #706e6b;">Slipped out of FY:</span> <span style="color: #ea8c55; font-size: 24px; font-weight: 900;">‚á¢</span> <span style="font-weight: bold;">${formatValue(slippedOutOfFY)}</span>`;
            }

            // Update right side with deal count including slipped out of FY count
            if (summary) {
                summary.textContent = `(${deals.length} deals, ${slippedOutOfFYCount} out of FY)`;
            }

            // Helper function to format date as "Nov, 2025"
            function formatMonthYear(dateStr) {
                if (!dateStr || dateStr === 'N/A') return 'N/A';
                try {
                    const parts = dateStr.split('.');
                    if (parts.length >= 3) {
                        const day = parseInt(parts[0].trim());
                        const month = parseInt(parts[1].trim()) - 1;
                        const year = parseInt(parts[2].trim());
                        const date = new Date(year, month, day);
                        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                        return `${monthNames[date.getMonth()]}, ${date.getFullYear()}`;
                    }
                } catch (e) {
                    console.error('Error formatting date:', dateStr, e);
                }
                return dateStr;
            }

            // Helper function to check if date is in current fiscal year
            function isInFY(dateStr) {
                if (!dateStr || dateStr === 'N/A') return false;
                try {
                    const parts = dateStr.split('.');
                    if (parts.length >= 3) {
                        const day = parseInt(parts[0].trim());
                        const month = parseInt(parts[1].trim()) - 1;
                        const year = parseInt(parts[2].trim());
                        const date = new Date(year, month, day);
                        return date >= FY_START && date <= FY_END;
                    }
                } catch (e) {
                    console.error('Error checking FY:', dateStr, e);
                }
                return false;
            }

            // Helper function to calculate days slipped
            function calculateDaysSlipped(oldDateStr, newDateStr) {
                try {
                    const oldParts = oldDateStr.split('.');
                    const newParts = newDateStr.split('.');
                    if (oldParts.length >= 3 && newParts.length >= 3) {
                        const oldDate = new Date(parseInt(oldParts[2]), parseInt(oldParts[1]) - 1, parseInt(oldParts[0]));
                        const newDate = new Date(parseInt(newParts[2]), parseInt(newParts[1]) - 1, parseInt(newParts[0]));
                        const diffTime = newDate - oldDate;
                        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                        return diffDays;
                    }
                } catch (e) {
                    console.error('Error calculating days:', e);
                }
                return 0;
            }

            // Sort deals:
            // 1. First group: slipped OUT of FY (was inside, now outside) - sorted by amount descending
            // 2. Second group: all others - sorted by old date ascending
            deals.sort((a, b) => {
                const aWasInFY = isInFY(a.oldDate);
                const aNowInFY = isInFY(a.newDate);
                const aSlippedOut = aWasInFY && !aNowInFY;

                const bWasInFY = isInFY(b.oldDate);
                const bNowInFY = isInFY(b.newDate);
                const bSlippedOut = bWasInFY && !bNowInFY;

                // If one slipped out of FY and other didn't, prioritize the one that slipped out
                if (aSlippedOut && !bSlippedOut) return -1;
                if (!aSlippedOut && bSlippedOut) return 1;

                // Both slipped out of FY - sort by amount descending
                if (aSlippedOut && bSlippedOut) {
                    return (b.amount || 0) - (a.amount || 0);
                }

                // Neither slipped out of FY - sort by old date ascending
                const aOldDate = parseEuropeanDate(a.oldDate);
                const bOldDate = parseEuropeanDate(b.oldDate);
                if (aOldDate && bOldDate) {
                    return aOldDate - bOldDate;
                }
                return 0;
            });

            let html = '';
            deals.forEach((deal, index) => {
                const sfLink = deal.oppId ? `https://cosylab.lightning.force.com/lightning/r/Opportunity/${deal.oppId}/view` : '#';
                const oppName = deal.oppId ? `<a href="${sfLink}" target="_blank" style="color: #0176d3; text-decoration: none;">${deal.name || 'N/A'}</a>` : (deal.name || 'N/A');

                const oldDateFormatted = formatMonthYear(deal.oldDate);
                const newDateFormatted = formatMonthYear(deal.newDate);

                // Check if slipped OUT of FY (was inside, now outside)
                const wasInFY = isInFY(deal.oldDate);
                const nowInFY = isInFY(deal.newDate);
                const slippedOutOfFY = wasInFY && !nowInFY;

                // Calculate days slipped
                const daysSlipped = calculateDaysSlipped(deal.oldDate, deal.newDate);

                // Visual indicator based on severity
                let slipIndicator = '';
                if (slippedOutOfFY) {
                    slipIndicator = ' <span style="color: #d32f2f; font-weight: bold; font-size: 1.2em;" title="Slipped out of current fiscal year">üî¥</span>';
                } else if (daysSlipped > 90) {
                    slipIndicator = ' <span style="color: #ff6f00; font-weight: bold; font-size: 1.2em;" title="Slipped more than 3 months">üü†</span>';
                } else if (daysSlipped > 30) {
                    slipIndicator = ' <span style="color: #ffa726; font-weight: bold; font-size: 1.2em;" title="Slipped more than 1 month">üü°</span>';
                }

                const slipInfo = daysSlipped > 0 ? ` (+${daysSlipped} days)` : '';

                html += `
                    <tr>
                        <td style="text-align: center; color: #706e6b;">${index + 1}</td>
                        <td>${oppName}</td>
                        <td>${deal.domain || '-'}</td>
                        <td>${deal.owner || 'N/A'}</td>
                        <td style="font-weight: 600;">${deal.amount ? formatValue(deal.amount) : '‚Ç¨0'}</td>
                        <td>
                            <span style="color: #706e6b;">${oldDateFormatted}</span>
                            <span style="color: #d32f2f; font-weight: bold;">‚Üí</span>
                            <span style="font-weight: 600;">${newDateFormatted}</span>
                            ${slipIndicator}
                            <span style="color: #999; font-size: 0.9em;">${slipInfo}</span>
                        </td>
                    </tr>
                `;
            });

            // Add total row
            const totalAmount = deals.reduce((sum, deal) => sum + (deal.amount || 0), 0);
            html += `
                <tr style="border-top: 2px solid #706e6b; background-color: #f3f2f2;">
                    <td></td>
                    <td colspan="3" style="text-align: right; font-weight: 700;">TOTAL:</td>
                    <td style="font-weight: 700;">${formatValue(totalAmount)}</td>
                    <td></td>
                </tr>
            `;

            tbody.innerHTML = html;
        }
        
        function populateNewDealsTable(deals) {
            const tbody = document.getElementById('newDealsBody');
            const summary = document.getElementById('newSummary');

            if (deals.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; color: #706e6b;">No new deals this week</td></tr>';
                if (summary) summary.textContent = '(0 deals)';
                return;
            }

            if (summary) {
                summary.textContent = `(${deals.length} deals)`;
            }

            let html = '';
            deals.forEach((deal, index) => {
                const sfLink = deal.oppId ? `https://cosylab.lightning.force.com/lightning/r/Opportunity/${deal.oppId}/view` : '#';
                const oppName = deal.oppId ? `<a href="${sfLink}" target="_blank" style="color: #0176d3; text-decoration: none;">${deal.name || 'N/A'}</a>` : (deal.name || 'N/A');

                html += `
                    <tr>
                        <td style="text-align: center; color: #706e6b;">${index + 1}</td>
                        <td>${oppName}</td>
                        <td>${deal.domain || '-'}</td>
                        <td>${deal.owner || 'N/A'}</td>
                        <td style="font-weight: 600;">${deal.amount ? formatValue(deal.amount) : '‚Ç¨0'}</td>
                        <td>${deal.closeDate || '-'}</td>
                        <td>${deal.stage || '-'}</td>
                    </tr>
                `;
            });

            // Add total row
            const totalAmount = deals.reduce((sum, deal) => sum + (deal.amount || 0), 0);
            html += `
                <tr style="border-top: 2px solid #706e6b; background-color: #f3f2f2;">
                    <td></td>
                    <td colspan="3" style="text-align: right; font-weight: 700;">TOTAL:</td>
                    <td style="font-weight: 700;">${formatValue(totalAmount)}</td>
                    <td></td>
                    <td></td>
                </tr>
            `;

            tbody.innerHTML = html;
        }
        
        function populateLostTable(deals) {
            const tbody = document.getElementById('lostBody');
            const summary = document.getElementById('lostSummary');

            if (deals.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; color: #706e6b;">No lost/disengaged deals this week</td></tr>';
                if (summary) summary.textContent = '(0 deals, ‚Ç¨0)';
                return;
            }

            // Calculate total
            const totalAmount = deals.reduce((sum, deal) => sum + (deal.amount || 0), 0);
            if (summary) {
                summary.textContent = `(${deals.length} deals, ${formatValue(totalAmount)})`;
            }

            let html = '';
            deals.forEach((deal, index) => {
                const sfLink = deal.oppId ? `https://cosylab.lightning.force.com/lightning/r/Opportunity/${deal.oppId}/view` : '#';
                const oppName = deal.oppId ? `<a href="${sfLink}" target="_blank" style="color: #0176d3; text-decoration: none;">${deal.name || 'N/A'}</a>` : (deal.name || 'N/A');

                // Determine badge color based on final stage
                const finalStage = deal.newStage || '-';
                const badgeColor = finalStage === 'Closed Lost' ? '#c23934' : '#f59331'; // red for Lost, orange for Disengaged
                const badgeText = finalStage === 'Closed Lost' ? 'Lost' : (finalStage === 'Closed Disengaged' ? 'Disengaged' : finalStage);

                html += `
                    <tr>
                        <td style="text-align: center; color: #706e6b;">${index + 1}</td>
                        <td>${oppName}</td>
                        <td>${deal.domain || '-'}</td>
                        <td>${deal.owner || 'N/A'}</td>
                        <td style="font-weight: 600;">${deal.amount ? formatValue(deal.amount) : '‚Ç¨0'}</td>
                        <td><span style="background-color: ${badgeColor}; color: white; padding: 2px 8px; border-radius: 3px; font-size: 0.85em; font-weight: 600;">${badgeText}</span></td>
                        <td>${deal.postMortem || '-'}</td>
                    </tr>
                `;
            });

            // Add total row
            html += `
                <tr style="border-top: 2px solid #706e6b; background-color: #f3f2f2;">
                    <td></td>
                    <td colspan="3" style="text-align: right; font-weight: 700;">TOTAL:</td>
                    <td style="font-weight: 700;">${formatValue(totalAmount)}</td>
                    <td></td>
                    <td></td>
                </tr>
            `;

            tbody.innerHTML = html;
        }

        function populateClosingThisWeekTable(deals) {
            const tbody = document.getElementById('closingThisWeekBody');
            const summary = document.getElementById('closingThisWeekSummary');
            const title = document.getElementById('closingThisWeekTitle');

            // Update title with date range
            const weekStart = new Date(calculationDate);
            const weekEnd = new Date(calculationDate);
            weekEnd.setDate(weekEnd.getDate() + 7);
            const startStr = weekStart.toLocaleDateString('en-GB', { day: '2-digit', month: '2-digit' });
            const endStr = weekEnd.toLocaleDateString('en-GB', { day: '2-digit', month: '2-digit' });
            if (title) title.textContent = `CLOSING THIS WEEK [${startStr} - ${endStr}]`;

            if (deals.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; color: #706e6b;">No deals closing this week</td></tr>';
                if (summary) summary.textContent = '(0 deals, ‚Ç¨0)';
                return;
            }

            // Calculate total
            const totalAmount = deals.reduce((sum, deal) => sum + (deal.amount || 0), 0);
            if (summary) {
                summary.textContent = `(${deals.length} deals, ${formatValue(totalAmount)})`;
            }

            let html = '';
            deals.forEach((deal, index) => {
                const sfLink = deal.oppId ? `https://cosylab.lightning.force.com/lightning/r/Opportunity/${deal.oppId}/view` : '#';
                const oppName = deal.oppId ? `<a href="${sfLink}" target="_blank" style="color: #0176d3; text-decoration: none;">${deal.name || 'N/A'}</a>` : (deal.name || 'N/A');

                html += `
                    <tr>
                        <td style="text-align: center; color: #706e6b;">${index + 1}</td>
                        <td>${oppName}</td>
                        <td>${deal.domain || '-'}</td>
                        <td>${deal.owner || 'N/A'}</td>
                        <td style="font-weight: 600;">${deal.amount ? formatValue(deal.amount) : '‚Ç¨0'}</td>
                        <td>${deal.closeDate || '-'}</td>
                        <td>${deal.stage || '-'}</td>
                    </tr>
                `;
            });

            // Add total row
            html += `
                <tr style="border-top: 2px solid #706e6b; background-color: #f3f2f2;">
                    <td></td>
                    <td colspan="3" style="text-align: right; font-weight: 700;">TOTAL:</td>
                    <td style="font-weight: 700;">${formatValue(totalAmount)}</td>
                    <td colspan="2"></td>
                </tr>
            `;

            tbody.innerHTML = html;
        }

        function populateClosingThisMonthTable(deals) {
            const tbody = document.getElementById('closingThisMonthBody');
            const summary = document.getElementById('closingThisMonthSummary');

            if (deals.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; color: #706e6b;">No deals closing this month</td></tr>';
                if (summary) summary.textContent = '(0 deals, ‚Ç¨0)';
                return;
            }

            // Calculate total
            const totalAmount = deals.reduce((sum, deal) => sum + (deal.amount || 0), 0);
            if (summary) {
                summary.textContent = `(${deals.length} deals, ${formatValue(totalAmount)})`;
            }

            let html = '';
            deals.forEach((deal, index) => {
                const sfLink = deal.oppId ? `https://cosylab.lightning.force.com/lightning/r/Opportunity/${deal.oppId}/view` : '#';
                const oppName = deal.oppId ? `<a href="${sfLink}" target="_blank" style="color: #0176d3; text-decoration: none;">${deal.name || 'N/A'}</a>` : (deal.name || 'N/A');

                html += `
                    <tr>
                        <td style="text-align: center; color: #706e6b;">${index + 1}</td>
                        <td>${oppName}</td>
                        <td>${deal.domain || '-'}</td>
                        <td>${deal.owner || 'N/A'}</td>
                        <td style="font-weight: 600;">${deal.amount ? formatValue(deal.amount) : '‚Ç¨0'}</td>
                        <td>${deal.closeDate || '-'}</td>
                        <td>${deal.stage || '-'}</td>
                    </tr>
                `;
            });

            // Add total row
            html += `
                <tr style="border-top: 2px solid #706e6b; background-color: #f3f2f2;">
                    <td></td>
                    <td colspan="3" style="text-align: right; font-weight: 700;">TOTAL:</td>
                    <td style="font-weight: 700;">${formatValue(totalAmount)}</td>
                    <td colspan="2"></td>
                </tr>
            `;

            tbody.innerHTML = html;
        }

        // List of all fullscreen-capable sections in order
        // Carousel order: 1, 2, 7, 8, 9, 3, 4, 5, 6, 10, 11, 12, 13
        const fullscreenSections = [
            'speedometerSection',           // Frame 1
            'barChartSection',              // Frame 2
            'closedGroup',                  // Frame 7
            'progressedGroup',              // Frame 8
            'slippedGroup',                 // Frame 9
            'pipelineFunnelSection',        // Frame 3
            'cumulativeChartSection',       // Frame 4
            'closingThisWeekSection',       // Frame 5
            'closingThisMonthSection',      // Frame 6
            'newDealsGroup',                // Frame 10
            'lostGroup',                    // Frame 11
            'closeDateChangesGroup',        // Frame 12
            'openCloseDateChangesGroup',    // Frame 13
            'q1OutlookSection'              // Frame 14
        ];

        const fullscreenFrameMap = {
            1: 'speedometerSection',
            2: 'barChartSection',
            3: 'pipelineFunnelSection',
            4: 'cumulativeChartSection',
            5: 'closingThisWeekSection',
            6: 'closingThisMonthSection',
            7: 'closedGroup',
            8: 'progressedGroup',
            9: 'slippedGroup',
            10: 'newDealsGroup',
            11: 'lostGroup',
            12: 'closeDateChangesGroup',
            13: 'openCloseDateChangesGroup',
            14: 'q1OutlookSection'
        };

        let currentFullscreenIndex = -1;
        let customFullscreenSequence = [];
        const FULLSCREEN_OPEN_ICON = '\u26F6';   // ‚õ∂ expand
        const FULLSCREEN_CLOSE_ICON = '\u2715';  // ‚úï close
        document.querySelectorAll('.fullscreen-btn').forEach(btn => {
            btn.textContent = FULLSCREEN_OPEN_ICON;
        });

        function getActiveFullscreenSequence() {
            return (customFullscreenSequence && customFullscreenSequence.length)
                ? customFullscreenSequence
                : fullscreenSections;
        }

        // Show/hide fullscreen indicator
        function updateFullscreenIndicator() {
            let indicator = document.getElementById('fullscreenIndicator');
            const activeSequence = getActiveFullscreenSequence();

            if (currentFullscreenIndex !== -1) {
                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.id = 'fullscreenIndicator';
                    indicator.className = 'fullscreen-indicator';
                    document.body.appendChild(indicator);
                }
                indicator.textContent = `Frame ${currentFullscreenIndex + 1} of ${activeSequence.length}`;
            } else if (indicator) {
                indicator.remove();
            }
        }

        // Owner group toggle functions for Close Date Changes table
        function toggleOwnerGroup(ownerIdx) {
            const detailRows = document.querySelectorAll(`.owner-group-${ownerIdx}`);
            const icon = document.getElementById(`toggle-icon-${ownerIdx}`);

            const isHidden = detailRows[0].style.display === 'none';

            detailRows.forEach(row => {
                row.style.display = isHidden ? 'table-row' : 'none';
            });

            icon.textContent = isHidden ? '‚ñº' : '‚ñ∂';
        }

        function toggleOpenOwnerGroup(ownerIdx) {
            const detailRows = document.querySelectorAll(`.open-owner-group-${ownerIdx}`);
            const icon = document.getElementById(`toggle-open-icon-${ownerIdx}`);

            const isHidden = detailRows[0].style.display === 'none';

            detailRows.forEach(row => {
                row.style.display = isHidden ? 'table-row' : 'none';
            });

            icon.textContent = isHidden ? '‚ñº' : '‚ñ∂';
        }

        function expandAllOwnerGroups() {
            const allDetailRows = document.querySelectorAll('.owner-detail-row');
            const allIcons = document.querySelectorAll('.toggle-icon');

            allDetailRows.forEach(row => {
                row.style.display = 'table-row';
            });

            allIcons.forEach(icon => {
                icon.textContent = '‚ñº';
            });
        }

        function collapseAllOwnerGroups() {
            const allDetailRows = document.querySelectorAll('.owner-detail-row');
            const allIcons = document.querySelectorAll('.toggle-icon');

            allDetailRows.forEach(row => {
                row.style.display = 'none';
            });

            allIcons.forEach(icon => {
                icon.textContent = '‚ñ∂';
            });
        }

                function applyFullscreenSection(sectionId) {
            // Reset any existing fullscreen section
            document.querySelectorAll('.section-fullscreen').forEach(sec => {
                sec.classList.remove('section-fullscreen');
                const btn = sec.querySelector('.fullscreen-btn');
                if (btn) {
                    btn.textContent = FULLSCREEN_OPEN_ICON;
                }
            });

            const target = document.getElementById(sectionId);
            if (!target) return;

            target.classList.add('section-fullscreen');
            const btn = target.querySelector('.fullscreen-btn');
            if (btn) {
                btn.textContent = FULLSCREEN_CLOSE_ICON;
            }

            const activeSequence = getActiveFullscreenSequence();
            const seqIndex = activeSequence.indexOf(sectionId);
            currentFullscreenIndex = seqIndex >= 0 ? seqIndex : fullscreenSections.indexOf(sectionId);
            updateFullscreenIndicator();
            redrawChartIfNeeded(sectionId);
            target.scrollIntoView({ behavior: 'instant', block: 'start' });
        }

        function parseFullscreenSequence(value) {
            const seen = new Set();
            return value
                .split(',')
                .map(v => v.trim())
                .filter(v => v.length > 0)
                .map(v => parseInt(v, 10))
                .filter(num => !Number.isNaN(num) && fullscreenFrameMap[num] && !seen.has(num) && seen.add(num));
        }

        function startFullscreenSequence() {
            const input = document.getElementById('fullscreenSequenceInput');
            if (!input) return;

            const frames = parseFullscreenSequence(input.value);

            if (!frames.length) {
                alert('Enter frame numbers separated by commas (e.g., 1,2,7)');
                return;
            }

            customFullscreenSequence = frames.map(num => fullscreenFrameMap[num]);
            // Move to the first frame in the chosen sequence for manual navigation
            if (customFullscreenSequence[0]) {
                applyFullscreenSection(customFullscreenSequence[0]);
            }
        }

        function stopFullscreenSequence() {
            // No-op now that auto-advance is disabled; kept for button compatibility
        }
        // Fullscreen toggle function
        function toggleFullscreen(sectionId) {
            const section = document.getElementById(sectionId);
            stopFullscreenSequence();
            const activeSequence = getActiveFullscreenSequence();

            if (!section.classList.contains('section-fullscreen')) {
                section.classList.add('section-fullscreen');
                const seqIndex = activeSequence.indexOf(sectionId);
                currentFullscreenIndex = seqIndex >= 0 ? seqIndex : fullscreenSections.indexOf(sectionId);

                const btn = section.querySelector('.fullscreen-btn');
                if (btn) btn.textContent = FULLSCREEN_CLOSE_ICON;

                updateFullscreenIndicator();
                redrawChartIfNeeded(sectionId);
            } else {
                section.classList.remove('section-fullscreen');
                currentFullscreenIndex = -1;

                const btn = section.querySelector('.fullscreen-btn');
                if (btn) btn.textContent = FULLSCREEN_OPEN_ICON;

                updateFullscreenIndicator();
                redrawChartIfNeeded(sectionId);
            }
        }

        function redrawChartIfNeeded(sectionId) {
            if (sectionId === 'speedometerSection') {
                setTimeout(() => {
                    setupHighDPICanvas(canvas);
                    drawSpeedometer();
                }, 100);
            } else if (sectionId === 'barChartSection') {
                setTimeout(() => drawBarChart(), 100);
            } else if (sectionId === 'pipelineFunnelSection') {
                setTimeout(() => drawPipelineFunnel(), 100);
            } else if (sectionId === 'cumulativeChartSection') {
                setTimeout(() => drawCumulativeChart(), 100);
            }
        }

        // Navigate to next/previous fullscreen section
        function navigateFullscreen(direction) {
            if (currentFullscreenIndex === -1) return; // Not in fullscreen mode

            const sequence = getActiveFullscreenSequence();
            if (!sequence.length) return;

            const currentSection = document.getElementById(sequence[currentFullscreenIndex]);
            if (currentSection) {
                currentSection.classList.remove('section-fullscreen');
                const btn = currentSection.querySelector('.fullscreen-btn');
                if (btn) btn.textContent = FULLSCREEN_OPEN_ICON;
            }

            let nextIndex = currentFullscreenIndex + direction;
            if (nextIndex < 0) nextIndex = sequence.length - 1; // Wrap to end
            if (nextIndex >= sequence.length) nextIndex = 0; // Wrap to start

            const nextSectionId = sequence[nextIndex];
            const nextSection = document.getElementById(nextSectionId);
            if (nextSection) {
                nextSection.classList.add('section-fullscreen');
                currentFullscreenIndex = nextIndex;
                const btn = nextSection.querySelector('.fullscreen-btn');
                if (btn) btn.textContent = FULLSCREEN_CLOSE_ICON;

                updateFullscreenIndicator();
                redrawChartIfNeeded(nextSectionId);
                nextSection.scrollIntoView({ behavior: 'instant', block: 'start' });
            }
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (currentFullscreenIndex === -1) return; // Not in fullscreen

            if (e.key === ' ' || e.key === 'ArrowRight' || e.key === 'ArrowDown') {
                e.preventDefault();
                navigateFullscreen(1); // Next
            } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
                e.preventDefault();
                navigateFullscreen(-1); // Previous
            } else if (e.key === 'Escape') {
                // Exit fullscreen on Escape
                const currentSection = document.getElementById(fullscreenSections[currentFullscreenIndex]);
                if (currentSection) {
                    toggleFullscreen(fullscreenSections[currentFullscreenIndex]);
                }
            }
        });

        // Initial draw
        drawSpeedometer();
        drawBarChart();
        drawPipelineFunnel();
            drawCumulativeChart();
        populateProgressTracking();
        
        // Set initial date
        const now = new Date();
        document.getElementById('dateInfo').textContent = `As of ${now.getDate()}. ${now.toLocaleString('en', {month: 'short'})}. ${now.getFullYear()}, ${now.getHours()}:${String(now.getMinutes()).padStart(2, '0')}`;
        
        // Set date picker to today
        const today = new Date();
        const dateString = today.toISOString().split('T')[0];
        document.getElementById('targetDate').value = dateString;

        // Set period selector to default (1 week)
        document.getElementById('periodRange').value = '7';
        selectedPeriodDays = 7;
        calculationDate = today;

        // Update period info display
        const periods = calculatePeriodDates();
        updatePeriodInfoDisplay(periods);

        // ============================================
        // Q1 FY26 PIPELINE OUTLOOK FUNCTIONS
        // ============================================

        /**
         * Aggregate Q1 FY26 data by domain
         * @param {Array} opportunities - Array of opportunity records
         * @returns {Object} Aggregated data by domain
         */
        function aggregateQ1Data(opportunities) {
            const result = {};

            opportunities.forEach(opp => {
                // Parse close date
                const closeDateStr = opp['Close Date'];
                if (!closeDateStr) return;

                let closeDate;
                try {
                    const parts = closeDateStr.split('. ');
                    if (parts.length !== 3) return;
                    const day = parseInt(parts[0]);
                    const month = parseInt(parts[1]);
                    const year = parseInt(parts[2]);
                    closeDate = new Date(year, month - 1, day);
                } catch (e) {
                    return;
                }

                // Filter: Q1 FY26 only (Apr-Jun 2025)
                if (closeDate < Q1_FY26_CONFIG.start || closeDate > Q1_FY26_CONFIG.end) return;

                // Exclude closed opportunities
                const stage = opp.Stage;
                if (!stage || stage.startsWith('Closed')) return;

                const domain = opp['Opportunity Domain'] || 'Other';
                const seller = opp['Opportunity Owner'] || 'Unknown';

                // Parse amount
                let amount = 0;
                const amountStr = opp['Net Amount'];
                if (amountStr && amountStr.startsWith('EUR')) {
                    try {
                        const cleanAmount = amountStr.substring(3).replace(/\./g, '').replace(',', '.');
                        amount = parseFloat(cleanAmount);
                    } catch (e) {
                        amount = 0;
                    }
                }

                // Initialize domain if needed
                if (!result[domain]) {
                    result[domain] = {
                        qualified: {},
                        early: {
                            identification: { count: 0, total: 0, ops: [] },
                            qualification: { count: 0, total: 0, ops: [] },
                            totalCount: 0,
                            totalAmount: 0
                        },
                        sellers: new Map() // Map: seller name -> count
                    };
                }

                // Count opportunities per seller
                if (!result[domain].sellers.has(seller)) {
                    result[domain].sellers.set(seller, 0);
                }
                result[domain].sellers.set(seller, result[domain].sellers.get(seller) + 1);

                // Categorize by stage
                if (stage === 'Opportunity Identification') {
                    result[domain].early.identification.count++;
                    result[domain].early.identification.total += amount;
                    result[domain].early.identification.ops.push({
                        name: opp['Opportunity Name'],
                        amount: amount,
                        closeDate: closeDate,
                        stage: stage
                    });
                    result[domain].early.totalCount++;
                    result[domain].early.totalAmount += amount;
                } else if (stage === 'Opportunity Qualification') {
                    result[domain].early.qualification.count++;
                    result[domain].early.qualification.total += amount;
                    result[domain].early.qualification.ops.push({
                        name: opp['Opportunity Name'],
                        amount: amount,
                        closeDate: closeDate,
                        stage: stage
                    });
                    result[domain].early.totalCount++;
                    result[domain].early.totalAmount += amount;
                } else if (Q1_FY26_CONFIG.qualifiedStages.includes(stage)) {
                    if (!result[domain].qualified[stage]) {
                        result[domain].qualified[stage] = { count: 0, total: 0, ops: [] };
                    }
                    result[domain].qualified[stage].count++;
                    result[domain].qualified[stage].total += amount;
                    result[domain].qualified[stage].ops.push({
                        name: opp['Opportunity Name'],
                        amount: amount,
                        closeDate: closeDate,
                        seller: seller
                    });
                }
            });

            return result;
        }

        /**
         * Calculate qualified pipeline total for a domain
         */
        function calculateQualifiedTotal(qualifiedData) {
            let total = 0;
            let count = 0;
            Object.values(qualifiedData).forEach(stage => {
                total += stage.total;
                count += stage.count;
            });
            return { total, count };
        }

        /**
         * Calculate weighted pipeline for a domain
         */
        function calculateWeightedPipeline(qualifiedData, earlyData) {
            let weighted = 0;

            // Qualified stages - use actual amounts
            Object.entries(qualifiedData).forEach(([stage, data]) => {
                const probability = STAGE_PROBABILITIES[stage] || 0;
                weighted += data.total * probability;
            });

            // Early stages - use average deal size for all opportunities
            if (earlyData) {
                // Identification - count √ó average √ó probability
                const identCount = earlyData.identification.count;
                weighted += identCount * AVERAGE_DEAL_SIZE * STAGE_PROBABILITIES['Opportunity Identification'];

                // Qualification - count √ó average √ó probability
                const qualifCount = earlyData.qualification.count;
                weighted += qualifCount * AVERAGE_DEAL_SIZE * STAGE_PROBABILITIES['Opportunity Qualification'];
            }

            return weighted;
        }

        /**
         * Format EUR currency
         */
        function formatEUR(value) {
            if (value >= 1000000) {
                return '‚Ç¨' + (value / 1000000).toFixed(2) + 'M';
            } else if (value >= 1000) {
                return '‚Ç¨' + (value / 1000).toFixed(0) + 'k';
            } else {
                return '‚Ç¨' + value.toFixed(0);
            }
        }

        /**
         * Render Q1 Outlook visualization
         */
        function renderQ1Outlook() {
            if (!currentPipelineData || currentPipelineData.length === 0) {
                document.getElementById('q1OutlookContent').innerHTML =
                    '<div style="text-align: center; padding: 40px; color: #706e6b;">No data loaded. Please upload CurrentPipeline.csv</div>';
                return;
            }

            // Aggregate data
            const q1Data = aggregateQ1Data(currentPipelineData);

            // Sort domains by qualified pipeline total (descending)
            const sortedDomains = Object.entries(q1Data).sort((a, b) => {
                const totalA = calculateQualifiedTotal(a[1].qualified).total;
                const totalB = calculateQualifiedTotal(b[1].qualified).total;
                return totalB - totalA;
            });

            // Find max value for scaling qualified bars
            const maxValue = Math.max(...sortedDomains.map(([, data]) =>
                calculateQualifiedTotal(data.qualified).total
            ));

            // Find max early stage count for scaling early bars
            const maxEarlyCount = Math.max(...sortedDomains.map(([, data]) =>
                data.early.totalCount
            ));

            // Render header
            let html = `
                <div class="q1-header-row">
                    <div class="q1-header-left">
                        <div style="min-width: 110px; text-align: right;">Domain</div>
                        <div>Qualified Pipeline</div>
                    </div>
                    <div class="q1-header-right">
                        <div>Early Stage</div>
                        <div style="font-size: 9px; text-transform: none; letter-spacing: 0;">(I + Q)</div>
                    </div>
                </div>
            `;

            // Render domains
            sortedDomains.forEach(([domain, data]) => {
                html += renderDomainBlock(domain, data, maxValue, maxEarlyCount);
            });

            document.getElementById('q1OutlookContent').innerHTML = html;

            // Render summary metrics
            renderQ1Summary(sortedDomains);
        }

        /**
         * Render single domain row
         */
        function renderDomainBlock(domainName, data, maxValue, maxEarlyCount) {
            const qualifiedTotal = calculateQualifiedTotal(data.qualified);
            // Calculate max bar width based on container width
            // Container is typically ~1000px, 65% = 650px
            // Minus domain name (110px) and gaps/padding (40px) = ~500px available
            const containerWidth = document.getElementById('q1OutlookContent').offsetWidth || 1000;
            const leftSectionWidth = containerWidth * 0.65;
            const maxBarWidth = leftSectionWidth - 110 - 40; // minus domain name width and padding
            const barWidth = maxValue > 0 ? (qualifiedTotal.total / maxValue) * maxBarWidth : 0;

            let html = `
                <div class="q1-domain-row">
                    <!-- Left Section: Domain + Qualified Bar -->
                    <div class="q1-left-section">
                        <div class="q1-domain-name">${domainName}</div>
                        <div class="q1-qualified-bar-wrapper">
                            <div class="q1-qualified-bar" style="width: ${barWidth}px;">
            `;

            // Render stage segments WITHOUT text labels
            const stages = ['Finalisation', 'Obtaining Final Commitment', 'A Winning Proposal', 'Value Creation'];
            let segmentOffset = 0;

            stages.forEach(stage => {
                if (data.qualified[stage]) {
                    const stageData = data.qualified[stage];
                    const segmentWidth = (stageData.total / qualifiedTotal.total) * barWidth;
                    const color = Q1_FY26_CONFIG.stageColors[stage];

                    html += `
                        <div class="q1-stage-segment"
                             style="width: ${segmentWidth}px; background: ${color};"
                             title="${stage}: ${formatEUR(stageData.total)} (${stageData.count} ops)">
                        </div>
                    `;
                }
            });

            // Add sum label ON the bar
            html += `
                                <div class="q1-bar-label">${formatEUR(qualifiedTotal.total)} (${qualifiedTotal.count} ops)</div>
                            </div>
                        </div>
                    </div>

                    <!-- Right Section: Early Stage + Sellers -->
                    <div class="q1-right-section">
                        <!-- Early Stage Bar -->
                        <div class="q1-early-bar-wrapper">
                            <div class="q1-early-bar">
            `;

            // Render early stage segments (I and Q)
            const earlyTotal = data.early.totalCount;
            const maxEarlyBarWidth = 200; // max width for early stage bar
            // Scale bar width based on totalCount relative to maxEarlyCount
            const earlyBarWidth = maxEarlyCount > 0 ? (earlyTotal / maxEarlyCount) * maxEarlyBarWidth : 0;

            if (earlyTotal > 0) {
                const identCount = data.early.identification.count;
                const qualifCount = data.early.qualification.count;

                if (identCount > 0) {
                    const identWidth = (identCount / earlyTotal) * earlyBarWidth;
                    html += `
                        <div class="q1-early-segment q1-early-identification"
                             style="width: ${identWidth}px;"
                             title="Identification: ${identCount} ops, ${formatEUR(data.early.identification.total)}">
                        </div>
                    `;
                }

                if (qualifCount > 0) {
                    const qualifWidth = (qualifCount / earlyTotal) * earlyBarWidth;
                    html += `
                        <div class="q1-early-segment q1-early-qualification"
                             style="width: ${qualifWidth}px;"
                             title="Qualification: ${qualifCount} ops, ${formatEUR(data.early.qualification.total)}">
                        </div>
                    `;
                }
            }

            html += `
                            </div>
                            <span class="q1-early-label">${data.early.identification.count}+${data.early.qualification.count} (${earlyTotal} ops)</span>
                        </div>

                        <!-- Sellers (under early stage bar) -->
                        <div class="q1-sellers-wrapper">
            `;

            // Render seller icons with opportunity count in tooltip
            const sellersArray = Array.from(data.sellers.entries());
            sellersArray.forEach(([seller, count]) => {
                html += `<span class="q1-seller-icon" title="${seller}: ${count} ops">üë§</span>`;
            });

            html += `
                        </div>
                    </div>
                </div>
            `;

            return html;
        }

        /**
         * Render summary metrics
         */
        function renderQ1Summary(sortedDomains) {
            let totalQualified = 0;
            let totalQualifiedCount = 0;
            let weightedPipeline = 0;
            let totalEarly = 0;
            let totalEarlyCount = 0;

            sortedDomains.forEach(([, data]) => {
                const qualified = calculateQualifiedTotal(data.qualified);
                totalQualified += qualified.total;
                totalQualifiedCount += qualified.count;
                weightedPipeline += calculateWeightedPipeline(data.qualified, data.early);
                totalEarly += data.early.totalAmount;
                totalEarlyCount += data.early.totalCount;
            });

            const coverage = Q1_FY26_CONFIG.target > 0 ? (weightedPipeline / Q1_FY26_CONFIG.target * 100).toFixed(0) : 0;
            const coverageClass = coverage >= 100 ? 'success' : coverage >= 70 ? 'warning' : 'danger';

            const html = `
                <div class="q1-summary-grid">
                    <div class="q1-summary-item">
                        <span class="q1-summary-label">Qualified Pipeline</span>
                        <span class="q1-summary-value">${formatEUR(totalQualified)} (${totalQualifiedCount} ops)</span>
                    </div>
                    <div class="q1-summary-item">
                        <span class="q1-summary-label">Early Stage</span>
                        <span class="q1-summary-value">${totalEarlyCount} ops (‚Ç¨${(AVERAGE_DEAL_SIZE/1000).toFixed(0)}k avg)</span>
                    </div>
                    <div class="q1-summary-item highlight">
                        <span class="q1-summary-label">Weighted Forecast</span>
                        <span class="q1-summary-value">${formatEUR(weightedPipeline)}</span>
                    </div>
                    <div class="q1-summary-item">
                        <span class="q1-summary-label">Target</span>
                        <span class="q1-summary-value">${formatEUR(Q1_FY26_CONFIG.target)}</span>
                    </div>
                    <div class="q1-summary-item ${coverageClass}">
                        <span class="q1-summary-label">Coverage</span>
                        <span class="q1-summary-value">${coverage}%</span>
                    </div>
                </div>
            `;

            document.getElementById('q1SummaryMetrics').innerHTML = html;
        }

        // Call renderQ1Outlook when data is loaded
        // This will be called automatically when CSV is loaded
    </script>
</body>
</html>
